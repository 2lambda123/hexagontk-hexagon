{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Hexagon Toolkit provides several libraries to build server applications. These libraries provide single standalone features 1 and are referred to as \"Ports\" . The main ports are: The HTTP server : supports HTTPS, HTTP/2, mutual TLS, static files (serve and upload), forms processing, cookies, sessions, CORS and more. The HTTP client : which supports mutual TLS, HTTP/2, cookies, form fields and files among other features. Template Processing : allows template processing from URLs (local files, resources or HTTP content) binding name patterns to different engines. Each of these features or ports may have different implementations called \"Adapters\" . Hexagon is designed to fit in applications that conform to the Hexagonal Architecture (also called Clean Architecture , Onion Architecture or Ports and Adapters Architecture ). Its design principles also fit into this architecture. Hello World \u00b6 Simple Hello World HTTP example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import com.hexagonkt.http.server.jetty.serve lateinit var server : HttpServer /** * Start a Hello World server, serving at path \"/hello\". */ fun main () { server = serve { get ( \"/hello/{name}\" ) { val name = pathParameters [ \"name\" ] ok ( \"Hello $ name !\" , contentType = ContentType ( PLAIN )) } } } You can check the code examples and demo projects for more complex use cases. Features \u00b6 Hexagon's goals and design principles: Put you in Charge : There is no code generation, no runtime annotation processing, no classpath based logic, and no implicit behaviour. You control your tools, not the other way around. Modular : Each feature (Port) or adapter is isolated in its own module. Use only the modules you need without carrying unneeded dependencies. Pluggable Adapters : Every Port may have many implementations (Adapters) using different technologies. You can swap adapters without changing the application code. Batteries Included : It contains all the required pieces to make production-grade applications: logging utilities, serialization, resource handling and build helpers. Kotlin First : Take full advantage of Kotlin instead of just calling Java code from Kotlin. The library is coded in Kotlin for coding with Kotlin. No strings attached to Java (as a Language). Properly Tested : The project's coverage is checked in every Pull Request. It is also stress-tested at TechEmpower Frameworks Benchmark . Not in Scope \u00b6 Kotlin Native : because of the added complexity of Kotlin Native, focus will be set on the JVM platform, native binaries' generation will rely on GraalVM. Architecture \u00b6 How Hexagon fits in your architecture in a picture. Note Using this toolkit won't make your application compliant with Hexagonal Architecture (by its nature, no tool can do that), you have to provide a layer of abstraction by yourself. Ports \u00b6 Ports with their provided implementations (Adapters). PORT ADAPTERS HTTP Server Jetty , Servlet HTTP Client Jetty Templates Pebble , FreeMarker Serialization Formats JSON , YAML , CSV , XML Except the Core module that contains a set of utilities like logging. However, some of these capacities can be replaced by other third party libraries. \u21a9","title":"Home"},{"location":"#hello-world","text":"Simple Hello World HTTP example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import com.hexagonkt.http.server.jetty.serve lateinit var server : HttpServer /** * Start a Hello World server, serving at path \"/hello\". */ fun main () { server = serve { get ( \"/hello/{name}\" ) { val name = pathParameters [ \"name\" ] ok ( \"Hello $ name !\" , contentType = ContentType ( PLAIN )) } } } You can check the code examples and demo projects for more complex use cases.","title":"Hello World"},{"location":"#features","text":"Hexagon's goals and design principles: Put you in Charge : There is no code generation, no runtime annotation processing, no classpath based logic, and no implicit behaviour. You control your tools, not the other way around. Modular : Each feature (Port) or adapter is isolated in its own module. Use only the modules you need without carrying unneeded dependencies. Pluggable Adapters : Every Port may have many implementations (Adapters) using different technologies. You can swap adapters without changing the application code. Batteries Included : It contains all the required pieces to make production-grade applications: logging utilities, serialization, resource handling and build helpers. Kotlin First : Take full advantage of Kotlin instead of just calling Java code from Kotlin. The library is coded in Kotlin for coding with Kotlin. No strings attached to Java (as a Language). Properly Tested : The project's coverage is checked in every Pull Request. It is also stress-tested at TechEmpower Frameworks Benchmark .","title":"Features"},{"location":"#not-in-scope","text":"Kotlin Native : because of the added complexity of Kotlin Native, focus will be set on the JVM platform, native binaries' generation will rely on GraalVM.","title":"Not in Scope"},{"location":"#architecture","text":"How Hexagon fits in your architecture in a picture. Note Using this toolkit won't make your application compliant with Hexagonal Architecture (by its nature, no tool can do that), you have to provide a layer of abstraction by yourself.","title":"Architecture"},{"location":"#ports","text":"Ports with their provided implementations (Adapters). PORT ADAPTERS HTTP Server Jetty , Servlet HTTP Client Jetty Templates Pebble , FreeMarker Serialization Formats JSON , YAML , CSV , XML Except the Core module that contains a set of utilities like logging. However, some of these capacities can be replaced by other third party libraries. \u21a9","title":"Ports"},{"location":"core/","text":"Module core \u00b6 This module holds utilities used in other libraries of the toolkit. Check the packages' documentation for more details. You can find a quick recap of the main features in the sections below. Install the Dependency \u00b6 This module is not meant to be imported directly. It will be included by using any other part of the toolkit. However, if you only want to use the utilities, logging, etc. (i.e., for a desktop application), you can import it with the following code: build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } implementation ( \"com.hexagonkt:core:$hexagonVersion\" ) 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> core </artifactId> <version> $hexagonVersion </version> </dependency> Package com.hexagonkt.core \u00b6 JVM information and other useful utilities. Classpath URLs in native images \u00b6 To use the 'classpath' URL scheme on GraalVM native images, the native-image command requires to add the Classpath handler manually with the --enable-url-protocols=classpath parameter. Flags (System Properties) \u00b6 DISABLE_CHECKS: set to true to disable some checks in order to shave a few ms. in production. Do not enable it in application development and turn it on only when the application is extensively tested. Package com.hexagonkt.core.converters \u00b6 Registry of functions to convert from one type to another. TODO Package com.hexagonkt.core.handlers \u00b6 TODO KEY TAKEAWAY: the order is NOT the order, it is the depth. Handlers are not linked, they are NESTED. The next() method passes control to the next level. So this: 1 2 3 H1 H2 H3 Is really: 1 2 3 4 5 H1 H2 H3 H2 H1 Package com.hexagonkt.core.logging \u00b6 Provides a logging management capabilities abstracting the application from logging libraries. The following code block shows the most common use cases for the Logger class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 val classLogger : Logger = Logger ( Runtime :: class ) // Logger for the `Runtime` class val instanceLogger : Logger = Logger ( this :: class ) // Logger for this instance's class logger . info { \"\"\" You can add a quick log without declaring a Logger with 'com.hexagonkt.helpers.logger'. It is a default logger created for the System class (same as `Logger(System::class)`). \"\"\" } classLogger . trace { \"Message only evaluated if trace enabled at ${ Jvm . id } \" } classLogger . debug { \"Message only evaluated if debug enabled at ${ Jvm . id } \" } classLogger . warn { \"Message only evaluated if warn enabled at ${ Jvm . id } \" } classLogger . info { \"Message only evaluated if info enabled at ${ Jvm . id } \" } val exception = IllegalStateException ( \"Exception\" ) classLogger . warn ( exception ) { \"Warning with exception\" } classLogger . error ( exception ) { \"Error message with exception\" } classLogger . warn ( exception ) classLogger . error ( exception ) classLogger . error { \"Error without an exception\" } classLogger . time ( \"Logs the time used to run the following block of code\" ) { val message = \"Block of code to be timed\" assert ( message . isNotBlank ()) } instanceLogger . flare { \"Prints a log that stands out for ease searching\" } // Logging level can be changed programmatically LoggingManager . setLoggerLevel ( ERROR ) LoggingManager . setLoggerLevel ( classLogger , DEBUG ) LoggingManager . setLoggerLevel ( \"com.hexagonkt\" , INFO ) By default, Hexagon uses the Java Util Logging logging library, you can use any of its implementations by just adding another logging adapter as a dependency. Below you can see some alternatives: Logback SLF4J JUL Package com.hexagonkt.core.logging.jul \u00b6 TODO Package com.hexagonkt.core.media \u00b6 TODO Package com.hexagonkt.core.security \u00b6 TODO","title":"Core"},{"location":"core/#module-core","text":"This module holds utilities used in other libraries of the toolkit. Check the packages' documentation for more details. You can find a quick recap of the main features in the sections below.","title":"Module core"},{"location":"core/#install-the-dependency","text":"This module is not meant to be imported directly. It will be included by using any other part of the toolkit. However, if you only want to use the utilities, logging, etc. (i.e., for a desktop application), you can import it with the following code: build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } implementation ( \"com.hexagonkt:core:$hexagonVersion\" ) 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> core </artifactId> <version> $hexagonVersion </version> </dependency>","title":"Install the Dependency"},{"location":"core/#package-comhexagonktcore","text":"JVM information and other useful utilities.","title":"Package com.hexagonkt.core"},{"location":"core/#classpath-urls-in-native-images","text":"To use the 'classpath' URL scheme on GraalVM native images, the native-image command requires to add the Classpath handler manually with the --enable-url-protocols=classpath parameter.","title":"Classpath URLs in native images"},{"location":"core/#flags-system-properties","text":"DISABLE_CHECKS: set to true to disable some checks in order to shave a few ms. in production. Do not enable it in application development and turn it on only when the application is extensively tested.","title":"Flags (System Properties)"},{"location":"core/#package-comhexagonktcoreconverters","text":"Registry of functions to convert from one type to another. TODO","title":"Package com.hexagonkt.core.converters"},{"location":"core/#package-comhexagonktcorehandlers","text":"TODO KEY TAKEAWAY: the order is NOT the order, it is the depth. Handlers are not linked, they are NESTED. The next() method passes control to the next level. So this: 1 2 3 H1 H2 H3 Is really: 1 2 3 4 5 H1 H2 H3 H2 H1","title":"Package com.hexagonkt.core.handlers"},{"location":"core/#package-comhexagonktcorelogging","text":"Provides a logging management capabilities abstracting the application from logging libraries. The following code block shows the most common use cases for the Logger class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 val classLogger : Logger = Logger ( Runtime :: class ) // Logger for the `Runtime` class val instanceLogger : Logger = Logger ( this :: class ) // Logger for this instance's class logger . info { \"\"\" You can add a quick log without declaring a Logger with 'com.hexagonkt.helpers.logger'. It is a default logger created for the System class (same as `Logger(System::class)`). \"\"\" } classLogger . trace { \"Message only evaluated if trace enabled at ${ Jvm . id } \" } classLogger . debug { \"Message only evaluated if debug enabled at ${ Jvm . id } \" } classLogger . warn { \"Message only evaluated if warn enabled at ${ Jvm . id } \" } classLogger . info { \"Message only evaluated if info enabled at ${ Jvm . id } \" } val exception = IllegalStateException ( \"Exception\" ) classLogger . warn ( exception ) { \"Warning with exception\" } classLogger . error ( exception ) { \"Error message with exception\" } classLogger . warn ( exception ) classLogger . error ( exception ) classLogger . error { \"Error without an exception\" } classLogger . time ( \"Logs the time used to run the following block of code\" ) { val message = \"Block of code to be timed\" assert ( message . isNotBlank ()) } instanceLogger . flare { \"Prints a log that stands out for ease searching\" } // Logging level can be changed programmatically LoggingManager . setLoggerLevel ( ERROR ) LoggingManager . setLoggerLevel ( classLogger , DEBUG ) LoggingManager . setLoggerLevel ( \"com.hexagonkt\" , INFO ) By default, Hexagon uses the Java Util Logging logging library, you can use any of its implementations by just adding another logging adapter as a dependency. Below you can see some alternatives: Logback SLF4J JUL","title":"Package com.hexagonkt.core.logging"},{"location":"core/#package-comhexagonktcoreloggingjul","text":"TODO","title":"Package com.hexagonkt.core.logging.jul"},{"location":"core/#package-comhexagonktcoremedia","text":"TODO","title":"Package com.hexagonkt.core.media"},{"location":"core/#package-comhexagonktcoresecurity","text":"TODO","title":"Package com.hexagonkt.core.security"},{"location":"developer_guide/","text":"Concepts \u00b6 Port \u00b6 It is an interface for a task. The toolkit ports are designed to work on their own. For example: you can use the http_server module without importing the templates one, and the other way around (taking only the dependencies you need for your application). Adapter \u00b6 They are implementations of a functionality (Port) for a given product/technology. Clients should only use ports' code (not Adapters specific code), this makes it easy to switch among different adapters with minimum impact. Adapters are independent of each other, but you can use several adapters for the same port in a single application. Manager \u00b6 Singleton object to manage a cross toolkit aspect. I.e., Serialization, Logging or Templates. Toolkit Structure \u00b6 The project is composed of modules, each module provides a single functionality. There are three kinds of modules: The ones that provide functionality that does not depend on different implementations, like core . These modules can depend on several Ports, but never on Adapters (see below). Modules that define one or more related \"Ports\": these are interfaces to a feature that may have different implementations (i.e., http_server or templates ). They cannot be used by themselves and in their place, an adapter implementing them should be added to the list of dependencies. Ports are independent of each other. Adapter modules, which are Port implementations for a given tool, http_client_jetty , and http_server_jetty are examples of this type of module. Adapter names must start with their port name. Hexagon Core \u00b6 The Hexagon Core module is used by all other libraries, so it would be added to your project anyway just by using any adapter. Core utilities like logging and resources access. Toolkit ports make use of Core functionalities. The main features are the following: Helpers : JVM information, a logger and other useful utilities. Converters : Registry of functions to convert from one type to another. Hexagon Extras \u00b6 The libraries inside the hexagon_extra repository provide extra features not bound to different implementations (rely on adapters to work). They will not use dependencies outside the Hexagon toolkit. Web : this module is meant to ease web application development. Provides helpers for generating HTML and depends on the HTTP Server and Templates ports. TODO Toolkit Ports \u00b6 These modules define features that need a specific implementation. You can use many implementations of each port at the same time. You can even provide a custom implementation if you want to optimize a particular use case. These are the implemented ports: HTTP Server : describes how to use HTTP routing and HTML templates for Web services. HTTP Client : documentation to use the HTTP client module to connect to other services. Templates : describes how to render pages using template engines.","title":"Developer Guide"},{"location":"developer_guide/#concepts","text":"","title":"Concepts"},{"location":"developer_guide/#port","text":"It is an interface for a task. The toolkit ports are designed to work on their own. For example: you can use the http_server module without importing the templates one, and the other way around (taking only the dependencies you need for your application).","title":"Port"},{"location":"developer_guide/#adapter","text":"They are implementations of a functionality (Port) for a given product/technology. Clients should only use ports' code (not Adapters specific code), this makes it easy to switch among different adapters with minimum impact. Adapters are independent of each other, but you can use several adapters for the same port in a single application.","title":"Adapter"},{"location":"developer_guide/#manager","text":"Singleton object to manage a cross toolkit aspect. I.e., Serialization, Logging or Templates.","title":"Manager"},{"location":"developer_guide/#toolkit-structure","text":"The project is composed of modules, each module provides a single functionality. There are three kinds of modules: The ones that provide functionality that does not depend on different implementations, like core . These modules can depend on several Ports, but never on Adapters (see below). Modules that define one or more related \"Ports\": these are interfaces to a feature that may have different implementations (i.e., http_server or templates ). They cannot be used by themselves and in their place, an adapter implementing them should be added to the list of dependencies. Ports are independent of each other. Adapter modules, which are Port implementations for a given tool, http_client_jetty , and http_server_jetty are examples of this type of module. Adapter names must start with their port name.","title":"Toolkit Structure"},{"location":"developer_guide/#hexagon-core","text":"The Hexagon Core module is used by all other libraries, so it would be added to your project anyway just by using any adapter. Core utilities like logging and resources access. Toolkit ports make use of Core functionalities. The main features are the following: Helpers : JVM information, a logger and other useful utilities. Converters : Registry of functions to convert from one type to another.","title":"Hexagon Core"},{"location":"developer_guide/#hexagon-extras","text":"The libraries inside the hexagon_extra repository provide extra features not bound to different implementations (rely on adapters to work). They will not use dependencies outside the Hexagon toolkit. Web : this module is meant to ease web application development. Provides helpers for generating HTML and depends on the HTTP Server and Templates ports. TODO","title":"Hexagon Extras"},{"location":"developer_guide/#toolkit-ports","text":"These modules define features that need a specific implementation. You can use many implementations of each port at the same time. You can even provide a custom implementation if you want to optimize a particular use case. These are the implemented ports: HTTP Server : describes how to use HTTP routing and HTML templates for Web services. HTTP Client : documentation to use the HTTP client module to connect to other services. Templates : describes how to render pages using template engines.","title":"Toolkit Ports"},{"location":"gradle/","text":"Build Variables \u00b6 The build process and imported build scripts (like the ones documented here) use variables to customize their behavior. It is possible to add/change variables of a build from the following places: In the project's gradle.properties file. In your user's gradle configuration: ~/.gradle/gradle.properties . Passing them from the command line with the following switch: -Pkey=val . Defining a project's extra property inside build.gradle . Ie: project.ext.key='val' . For examples and reference, check build.gradle and gradle.properties . Helper scripts \u00b6 These scripts can be added to your build to include a whole new capability to your building logic. To use them, you can import the online versions, or copy them to your gradle directory before importing the script. You can import these scripts by adding add apply from: $gradleScripts/$script.gradle to your build.gradle file some of them may require additional plugins inside the plugins section in the root build.gradle . Check toolkit build.gradle files for examples. Publish \u00b6 This script set up the project/module for publishing in Maven Central . It publishes all artifacts attached to the mavenJava publication (check kotlin.gradle publishing section) at the bare minimum binaries are published. For an Open Source project, you must include sources and javadoc. To use it, apply $gradleScripts/publish.gradle . To set up this script's parameters, check the build variables section . These helper settings are: bintrayKey (REQUIRED): if not defined will try to load BINTRAY_KEY environment variable. bintrayUser (REQUIRED): or BINTRAY_USER environment variable if not defined. license (REQUIRED): the license used in published POMs. vcsUrl (REQUIRED): code repository location. Dokka \u00b6 This script set up Dokka tool and add a JAR with the project's code documentation to the published JARs. It adds the following extra task: dokkaJar: create a jar file with the source code documentation in Javadoc format. All modules' Markdown files are added to the documentation and test classes ending in SamplesTest are available to be referenced as samples. To use it, apply $gradleScripts/dokka.gradle and add the id 'org.jetbrains.dokka' version 'VERSION' plugin to the root build.gradle . The format for the generated documentation will be javadoc to make it compatible with current IDEs. Icons \u00b6 Create web icons (favicon and thumbnails for browsers/mobile) from image SVGs (logos). For image rendering you will need rsvg (librsvg2-bin) and imagemagick installed in the development machine. To use it, apply $gradleScripts/icons.gradle to your build.gradle . To set up this script's parameters, check the build variables section . These helper settings are: logo (REQUIRED): SVG file used to render the logos. Used for the favicon. logoLarge: SVG file used to render the large logo. If not supplied 'logo' will be used. logoWide: SVG file used to render the wide logo. Used for MS Windows tiles. If not provided 'logoLarge' will be used. Kotlin \u00b6 Adds Kotlin's Gradle plugin. Uses JUnit 5 as the test framework. It also includes MockK in the test classpath. It sets up: Java version Repositories Kotlin dependencies Resource processing (replacing build variables) Cleaning (deleting runtime files as logs and dump files) Tests run, handles properties, output, and mocks (test's output depends on Gradle logging level) Set up coverage report IDE settings for IntelliJ and Eclipse (download dependencies' sources and API documentation) Published artifacts (binaries and sources): sourcesJar task To use it, apply $gradleScripts/kotlin.gradle and add the id 'org.jetbrains.kotlin.jvm' version 'VERSION' plugin to the root build.gradle . To set up this script's parameters, check the build variables section . These helper settings are: kotlinVersion: Kotlin version. Defaults to the version used in the matching Hexagon release. mockkVersion: MockK mocking library version. If no value is supplied, Hexagon's version is taken. junitVersion: JUnit version (5+), the default value is the toolkit version. basePackage: Module's base package (used by the Jacoco Report when using Kotlin Coding Standard) Application \u00b6 Gradle's script for a service or application. It adds these extra tasks: buildInfo: add configuration file ( META-INF/build.properties ) with build variables to the package. It is executed automatically before compiling classes. watch: run the application in another thread. Allows the possibility to watch source changes. To run the application and watch for changes you need to execute this task with the --continuous ( -t ) Gradle flag. Ie: gw -t watch . jarAll: creates a single JAR with all dependencies, and the application main class set up. This task is an alternative to the Gradle installDist task. To use it, apply $gradleScripts/application.gradle to your build.gradle . To set up this script you need to add the main class name to your build.gradle file with the following code: 1 2 3 application { mainClass . set ( \"com.example.ApplicationKt\" ) } Certificates \u00b6 Creates the required key stores for development purposes. IMPORTANT these key stores must not be used for production environments. The created key stores are: ca.p12 : self-signed certificate authority (CA). This store holds the CA private key. The store must be private and will be used to sign other certificates. The key pair alias is ca . trust.p12 : key store with CA's public certificate. It can be set as the Java process trust store which makes every certificate signed with the CA trusted. However, if used as the trust store, the JDK cacerts entries won't be loaded and thus, not trusted. It can be used to set up HTTPS clients (not required to be set at JVM level). <domain>.p12 : there would be one per each domain (see sslDomain variable). These stores are signed by the CA, and they contain the service private key and its full chain certificate. <domain> will be the domain name without the TLD, and the Subject alternative names (SAN) will include <domain>.test ( TLD for local environments ) and localhost (along the extra subdomains specified). The defined tasks are: createCa: creates ca.p12 and import its public certificate inside trust.p12 . createIdentities: creates the <domain>.p12 store for all sslDomain variables. To use it, apply $gradleScripts/certificates.gradle to your build.gradle . To set up this script's parameters, check the build variables section . These helper settings are: sslDomain[1-9] (REQUIRED): the main domain for the identity store. You can create up to ten (from sslDomain to sslDomain9 ). Each of these variables has the format subdomain1|subdomain2|subdomainN|domain.tld subdomains are added to <domain>.p12 alternative names (aside of <domain>.test and localhost which are always added). By default, no extra domains are added to the key store. sslOrganization (REQUIRED): organization stated in created certificates. sslCaFile: certificate authority key store file. By default: \"ca.p12\". sslCaAlias: CA alias in the key store. If not provided, it will be \"ca\". sslTrustFile: trust store file name, by default it is \"trust.p12\". sslPath: path used to generate the key stores. By default, it will be the project's build directory. sslPassword: password used for the generated key stores. By default, it is the file name reversed. sslValidity: validity period (in days) for certificates. If not provided, it will be 365. sslCountry: country used in the certificates. By default, it is the current locale's country code. Lean \u00b6 This script changes the default Gradle source layout to be less bulky. To use it you must apply the $gradleScripts/lean.gradle script to your build.gradle file. It must be applied after the Kotlin plugin. After applying this script, the source folders will be ${projectDir}/main and ${projectDir}/test , and the resources will be stored also in these folders. Detekt \u00b6 This script sets up the build to analyze the code with the Detekt static code analyzer. To use it you must apply the $gradleScripts/detekt.gradle script to your build.gradle file. It must be applied after the Kotlin plugin. For the script to work you need to add the plugin to the plugins build section before importing the script. I.e.: 1 2 3 plugins { id ( \"io.gitlab.arturbosch.detekt\" ) version \"VERSION\" apply false } To set up this script's parameters, check the build variables section . These helper settings are: detektConfigPath: file with Detekt rules and settings. If not set, the default Detekt setup will be used.","title":"Gradle Helpers"},{"location":"gradle/#build-variables","text":"The build process and imported build scripts (like the ones documented here) use variables to customize their behavior. It is possible to add/change variables of a build from the following places: In the project's gradle.properties file. In your user's gradle configuration: ~/.gradle/gradle.properties . Passing them from the command line with the following switch: -Pkey=val . Defining a project's extra property inside build.gradle . Ie: project.ext.key='val' . For examples and reference, check build.gradle and gradle.properties .","title":"Build Variables"},{"location":"gradle/#helper-scripts","text":"These scripts can be added to your build to include a whole new capability to your building logic. To use them, you can import the online versions, or copy them to your gradle directory before importing the script. You can import these scripts by adding add apply from: $gradleScripts/$script.gradle to your build.gradle file some of them may require additional plugins inside the plugins section in the root build.gradle . Check toolkit build.gradle files for examples.","title":"Helper scripts"},{"location":"gradle/#publish","text":"This script set up the project/module for publishing in Maven Central . It publishes all artifacts attached to the mavenJava publication (check kotlin.gradle publishing section) at the bare minimum binaries are published. For an Open Source project, you must include sources and javadoc. To use it, apply $gradleScripts/publish.gradle . To set up this script's parameters, check the build variables section . These helper settings are: bintrayKey (REQUIRED): if not defined will try to load BINTRAY_KEY environment variable. bintrayUser (REQUIRED): or BINTRAY_USER environment variable if not defined. license (REQUIRED): the license used in published POMs. vcsUrl (REQUIRED): code repository location.","title":"Publish"},{"location":"gradle/#dokka","text":"This script set up Dokka tool and add a JAR with the project's code documentation to the published JARs. It adds the following extra task: dokkaJar: create a jar file with the source code documentation in Javadoc format. All modules' Markdown files are added to the documentation and test classes ending in SamplesTest are available to be referenced as samples. To use it, apply $gradleScripts/dokka.gradle and add the id 'org.jetbrains.dokka' version 'VERSION' plugin to the root build.gradle . The format for the generated documentation will be javadoc to make it compatible with current IDEs.","title":"Dokka"},{"location":"gradle/#icons","text":"Create web icons (favicon and thumbnails for browsers/mobile) from image SVGs (logos). For image rendering you will need rsvg (librsvg2-bin) and imagemagick installed in the development machine. To use it, apply $gradleScripts/icons.gradle to your build.gradle . To set up this script's parameters, check the build variables section . These helper settings are: logo (REQUIRED): SVG file used to render the logos. Used for the favicon. logoLarge: SVG file used to render the large logo. If not supplied 'logo' will be used. logoWide: SVG file used to render the wide logo. Used for MS Windows tiles. If not provided 'logoLarge' will be used.","title":"Icons"},{"location":"gradle/#kotlin","text":"Adds Kotlin's Gradle plugin. Uses JUnit 5 as the test framework. It also includes MockK in the test classpath. It sets up: Java version Repositories Kotlin dependencies Resource processing (replacing build variables) Cleaning (deleting runtime files as logs and dump files) Tests run, handles properties, output, and mocks (test's output depends on Gradle logging level) Set up coverage report IDE settings for IntelliJ and Eclipse (download dependencies' sources and API documentation) Published artifacts (binaries and sources): sourcesJar task To use it, apply $gradleScripts/kotlin.gradle and add the id 'org.jetbrains.kotlin.jvm' version 'VERSION' plugin to the root build.gradle . To set up this script's parameters, check the build variables section . These helper settings are: kotlinVersion: Kotlin version. Defaults to the version used in the matching Hexagon release. mockkVersion: MockK mocking library version. If no value is supplied, Hexagon's version is taken. junitVersion: JUnit version (5+), the default value is the toolkit version. basePackage: Module's base package (used by the Jacoco Report when using Kotlin Coding Standard)","title":"Kotlin"},{"location":"gradle/#application","text":"Gradle's script for a service or application. It adds these extra tasks: buildInfo: add configuration file ( META-INF/build.properties ) with build variables to the package. It is executed automatically before compiling classes. watch: run the application in another thread. Allows the possibility to watch source changes. To run the application and watch for changes you need to execute this task with the --continuous ( -t ) Gradle flag. Ie: gw -t watch . jarAll: creates a single JAR with all dependencies, and the application main class set up. This task is an alternative to the Gradle installDist task. To use it, apply $gradleScripts/application.gradle to your build.gradle . To set up this script you need to add the main class name to your build.gradle file with the following code: 1 2 3 application { mainClass . set ( \"com.example.ApplicationKt\" ) }","title":"Application"},{"location":"gradle/#certificates","text":"Creates the required key stores for development purposes. IMPORTANT these key stores must not be used for production environments. The created key stores are: ca.p12 : self-signed certificate authority (CA). This store holds the CA private key. The store must be private and will be used to sign other certificates. The key pair alias is ca . trust.p12 : key store with CA's public certificate. It can be set as the Java process trust store which makes every certificate signed with the CA trusted. However, if used as the trust store, the JDK cacerts entries won't be loaded and thus, not trusted. It can be used to set up HTTPS clients (not required to be set at JVM level). <domain>.p12 : there would be one per each domain (see sslDomain variable). These stores are signed by the CA, and they contain the service private key and its full chain certificate. <domain> will be the domain name without the TLD, and the Subject alternative names (SAN) will include <domain>.test ( TLD for local environments ) and localhost (along the extra subdomains specified). The defined tasks are: createCa: creates ca.p12 and import its public certificate inside trust.p12 . createIdentities: creates the <domain>.p12 store for all sslDomain variables. To use it, apply $gradleScripts/certificates.gradle to your build.gradle . To set up this script's parameters, check the build variables section . These helper settings are: sslDomain[1-9] (REQUIRED): the main domain for the identity store. You can create up to ten (from sslDomain to sslDomain9 ). Each of these variables has the format subdomain1|subdomain2|subdomainN|domain.tld subdomains are added to <domain>.p12 alternative names (aside of <domain>.test and localhost which are always added). By default, no extra domains are added to the key store. sslOrganization (REQUIRED): organization stated in created certificates. sslCaFile: certificate authority key store file. By default: \"ca.p12\". sslCaAlias: CA alias in the key store. If not provided, it will be \"ca\". sslTrustFile: trust store file name, by default it is \"trust.p12\". sslPath: path used to generate the key stores. By default, it will be the project's build directory. sslPassword: password used for the generated key stores. By default, it is the file name reversed. sslValidity: validity period (in days) for certificates. If not provided, it will be 365. sslCountry: country used in the certificates. By default, it is the current locale's country code.","title":"Certificates"},{"location":"gradle/#lean","text":"This script changes the default Gradle source layout to be less bulky. To use it you must apply the $gradleScripts/lean.gradle script to your build.gradle file. It must be applied after the Kotlin plugin. After applying this script, the source folders will be ${projectDir}/main and ${projectDir}/test , and the resources will be stored also in these folders.","title":"Lean"},{"location":"gradle/#detekt","text":"This script sets up the build to analyze the code with the Detekt static code analyzer. To use it you must apply the $gradleScripts/detekt.gradle script to your build.gradle file. It must be applied after the Kotlin plugin. For the script to work you need to add the plugin to the plugins build section before importing the script. I.e.: 1 2 3 plugins { id ( \"io.gitlab.arturbosch.detekt\" ) version \"VERSION\" apply false } To set up this script's parameters, check the build variables section . These helper settings are: detektConfigPath: file with Detekt rules and settings. If not set, the default Detekt setup will be used.","title":"Detekt"},{"location":"help/","text":"Support \u00b6 Please, check if your issue already exists at the organization board or the issues list before creating a new one. To report a bug, create a new bug issue using GitHub. You can also write an email at support@hexagonkt.com to ask for support. Help \u00b6 You can use Slack for questions, comments, etc. you can also create a GitHub discussion on the Q&A section.","title":"Help and Support"},{"location":"help/#support","text":"Please, check if your issue already exists at the organization board or the issues list before creating a new one. To report a bug, create a new bug issue using GitHub. You can also write an email at support@hexagonkt.com to ask for support.","title":"Support"},{"location":"help/#help","text":"You can use Slack for questions, comments, etc. you can also create a GitHub discussion on the Q&A section.","title":"Help"},{"location":"http/","text":"Module http \u00b6 This module holds HTTP classes and utilities independent of third party libraries and shared among HTTP clients and HTTP servers. Package com.hexagonkt.http \u00b6 HTTP code shared between clients and servers. Package com.hexagonkt.http.model \u00b6 TODO Package com.hexagonkt.http.patterns \u00b6 TODO","title":"Module http"},{"location":"http/#module-http","text":"This module holds HTTP classes and utilities independent of third party libraries and shared among HTTP clients and HTTP servers.","title":"Module http"},{"location":"http/#package-comhexagonkthttp","text":"HTTP code shared between clients and servers.","title":"Package com.hexagonkt.http"},{"location":"http/#package-comhexagonkthttpmodel","text":"TODO","title":"Package com.hexagonkt.http.model"},{"location":"http/#package-comhexagonkthttppatterns","text":"TODO","title":"Package com.hexagonkt.http.patterns"},{"location":"http_client/","text":"Module http_client \u00b6 This port provides a common interface for using HTTP clients. Many adapters can be developed to use different technologies. Its main functionalities are: HTTP, HTTPS and HTTP/2 support Mutual TLS Body encoding/decoding Request/response exchange Form submissions Cookie management File uploading/downloading Install the Dependency \u00b6 This module is not meant to be used directly. You should include an Adapter implementing this feature (as http_client_jetty ) in order to create HTTP clients. Create an HTTP client \u00b6 You create an HTTP Client instance with default options as follows: 1 2 HttpClient ( adapter ) HttpClient ( adapter , URL ( \"http://host:1234/base\" )) Settings \u00b6 If you want to configure options for the client, you can create it with the following code: 1 2 3 4 5 6 7 8 9 // All client settings parameters are optionals and provide default values HttpClient ( adapter , HttpClientSettings ( baseUrl = URL ( \"http://host:1234/base\" ), contentType = ContentType ( JSON ), useCookies = true , headers = multiMapOf ( \"x-api-Key\" to \"cafebabe\" ), // Headers used in all requests insecure = false , // If true, the client doesn't check server certificates sslSettings = SslSettings () // Key stores settings (check TLS section for details) )) Send generic requests \u00b6 The most common use case is to send a request and get a response. For details about how to use requests and responses, refer to the Request and the Response API. Check this code snippet to get a glimpse on how to send the most general requests: 1 2 3 4 5 6 7 8 9 10 val request = HttpClientRequest ( method = GET , path = \"/\" , body = mapOf ( \"body\" to \"payload\" ). serialize (), headers = multiMapOf ( \"x-header\" to \"value\" ), queryParameters = multiMapOf ( \"qp\" to \"qpValue\" ), contentType = ContentType ( JSON ) ) val response = client . send ( request ) Simple requests shortcuts \u00b6 There are utility methods to make the most common request in an easy way. Without body \u00b6 1 2 3 4 5 6 7 8 val responseGet = client . get ( \"/\" ) val responseHead = client . head ( \"/\" ) val responsePost = client . post ( \"/\" ) val responsePut = client . put ( \"/\" ) val responseDelete = client . delete ( \"/\" ) val responseTrace = client . trace ( \"/\" ) val responseOptions = client . options ( \"/\" ) val responsePatch = client . patch ( \"/\" ) With body \u00b6 1 2 3 4 5 6 7 8 9 10 val body = mapOf ( \"key\" to \"value\" ) val serializedBody = body . serialize () val responseGet = client . get ( \"/\" , body = serializedBody ) val responsePost = client . post ( \"/\" , serializedBody ) val responsePut = client . put ( \"/\" , serializedBody ) val responseDelete = client . delete ( \"/\" , serializedBody ) val responseTrace = client . trace ( \"/\" , serializedBody ) val responseOptions = client . options ( \"/\" , serializedBody ) val responsePatch = client . patch ( \"/\" , serializedBody ) With body and content type \u00b6 1 2 3 4 5 6 7 8 9 10 val body = mapOf ( \"key\" to \"value\" ) val serializedBody = body . serialize ( YAML ) val responseGet = client . get ( \"/\" , body = serializedBody , contentType = ContentType ( YAML )) val responsePost = client . post ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responsePut = client . put ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responseDelete = client . delete ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responseTrace = client . trace ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responseOptions = client . options ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responsePatch = client . patch ( \"/\" , serializedBody , contentType = ContentType ( YAML )) Cookies \u00b6 The HTTP client support setting cookies from client side and updates them after any server request. Check the details in the following code fragment: 1 2 3 4 5 6 7 8 9 10 11 12 val cookieName = \"sampleCookie\" val cookieValue = \"sampleCookieValue\" // Set the cookie in the client client . cookies = client . cookies + HttpCookie ( cookieName , cookieValue ) // Assert that it is received in the server and change its value afterwards client . post ( \"/assertHasCookie?cookieName= $ cookieName \" ) client . post ( \"/addCookie?cookieName= $ cookieName &cookieValue= ${ cookieValue } _changed\" ) // Verify that the client cookie is updated assertEquals ( cookieValue + \"_changed\" , client . cookiesMap () [ cookieName ]?. value ) You can also check the full test for more details. Multipart (forms and files) \u00b6 Using the HTTP client you can send MIME multipart parts to the server. You can use it to post forms or files. Forms \u00b6 1 2 val parts = listOf ( HttpPart ( \"name\" , \"value\" )) val response = client . send ( HttpClientRequest ( POST , path = \"/multipart\" , parts = parts )) Files \u00b6 1 2 3 val stream = URL ( \"classpath:assets/index.html\" ). readBytes () val parts = listOf ( HttpPart ( \"file\" , stream , \"index.html\" )) val response = client . send ( HttpClientRequest ( POST , path = \"/file\" , parts = parts )) TLS \u00b6 The HTTP client supports server certificates (to use HTTPS and HTTP/2) and also client certificates (to be able to do mutual TLS). Key stores may have the JKS format (deprecated), or the newer PKCS12 format. To set up client/server certificates, you need to include SslSettings in your ClientSettings . In the sections below you can see how to configure these parameters. Key Store \u00b6 This store holds the identity certificate, this certificate is presented to the server by the client in the handshake for the server to authorize or deny the connection. The following code: 1 2 3 4 val keyStoreSettings = SslSettings ( keyStore = URL ( \"classpath:ssl/ $ identity \" ), keyStorePassword = identity . reversed () ) Trust Store \u00b6 This key store should include all the trusted certificates. Any certificate added as CA (certificate authority) makes the client trust any other certificate signed by them. However, you can also add standalone server certificates. 1 2 3 4 val trustStoreSettings = SslSettings ( trustStore = URL ( \"classpath:ssl/ $ trust \" ), trustStorePassword = trust . reversed () ) Mutual TLS \u00b6 If you set up the identity (service's own certificate) and the trust store (CAs and servers trusted by the client), you will achieve double ended authentication (server authenticated by the client, and client authenticated by the server). You can see a complete example below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Key store files val identity = \"hexagonkt.p12\" val trust = \"trust.p12\" // Default passwords are file name reversed val keyStorePassword = identity . reversed () val trustStorePassword = trust . reversed () // Key stores can be set as URIs to classpath resources (the triple slash is needed) val keyStore = URL ( \"classpath:ssl/ $ identity \" ) val trustStore = URL ( \"classpath:ssl/ $ trust \" ) val sslSettings = SslSettings ( keyStore = keyStore , keyStorePassword = keyStorePassword , trustStore = trustStore , trustStorePassword = trustStorePassword , clientAuth = true // Requires a valid certificate from the client (mutual TLS) ) val serverSettings = HttpServerSettings ( bindPort = 0 , protocol = HTTPS , // You can also use HTTP2 sslSettings = sslSettings ) val server = HttpServer ( serverAdapter (), serverSettings ) { get ( \"/hello\" ) { // We can access the certificate used by the client from the request val subjectDn = request . certificate () ?. subjectX500Principal ?. name ?: \"\" val h = response . headers + ( \"cert\" to subjectDn ) ok ( \"Hello World!\" , headers = h ) } } server . start () // We'll use the same certificate for the client (in a real scenario it would be different) val clientSettings = HttpClientSettings ( sslSettings = sslSettings ) // Create an HTTP client and make an HTTPS request val contextPath = URL ( \"https://localhost: ${ server . runtimePort } \" ) val client = HttpClient ( clientAdapter (), contextPath , clientSettings ) client . start () client . get ( \"/hello\" ). apply { logger . debug { body } // Assure the certificate received (and returned) by the server is correct assert ( headers . require ( \"cert\" ). startsWith ( \"CN=hexagonkt.com\" )) assertEquals ( \"Hello World!\" , body ) } Package com.hexagonkt.http.client \u00b6 This package holds the classes that define the HTTP client and its configuration settings. Package com.hexagonkt.http.client.model \u00b6 TODO","title":"HTTP Client"},{"location":"http_client/#module-http_client","text":"This port provides a common interface for using HTTP clients. Many adapters can be developed to use different technologies. Its main functionalities are: HTTP, HTTPS and HTTP/2 support Mutual TLS Body encoding/decoding Request/response exchange Form submissions Cookie management File uploading/downloading","title":"Module http_client"},{"location":"http_client/#install-the-dependency","text":"This module is not meant to be used directly. You should include an Adapter implementing this feature (as http_client_jetty ) in order to create HTTP clients.","title":"Install the Dependency"},{"location":"http_client/#create-an-http-client","text":"You create an HTTP Client instance with default options as follows: 1 2 HttpClient ( adapter ) HttpClient ( adapter , URL ( \"http://host:1234/base\" ))","title":"Create an HTTP client"},{"location":"http_client/#settings","text":"If you want to configure options for the client, you can create it with the following code: 1 2 3 4 5 6 7 8 9 // All client settings parameters are optionals and provide default values HttpClient ( adapter , HttpClientSettings ( baseUrl = URL ( \"http://host:1234/base\" ), contentType = ContentType ( JSON ), useCookies = true , headers = multiMapOf ( \"x-api-Key\" to \"cafebabe\" ), // Headers used in all requests insecure = false , // If true, the client doesn't check server certificates sslSettings = SslSettings () // Key stores settings (check TLS section for details) ))","title":"Settings"},{"location":"http_client/#send-generic-requests","text":"The most common use case is to send a request and get a response. For details about how to use requests and responses, refer to the Request and the Response API. Check this code snippet to get a glimpse on how to send the most general requests: 1 2 3 4 5 6 7 8 9 10 val request = HttpClientRequest ( method = GET , path = \"/\" , body = mapOf ( \"body\" to \"payload\" ). serialize (), headers = multiMapOf ( \"x-header\" to \"value\" ), queryParameters = multiMapOf ( \"qp\" to \"qpValue\" ), contentType = ContentType ( JSON ) ) val response = client . send ( request )","title":"Send generic requests"},{"location":"http_client/#simple-requests-shortcuts","text":"There are utility methods to make the most common request in an easy way.","title":"Simple requests shortcuts"},{"location":"http_client/#without-body","text":"1 2 3 4 5 6 7 8 val responseGet = client . get ( \"/\" ) val responseHead = client . head ( \"/\" ) val responsePost = client . post ( \"/\" ) val responsePut = client . put ( \"/\" ) val responseDelete = client . delete ( \"/\" ) val responseTrace = client . trace ( \"/\" ) val responseOptions = client . options ( \"/\" ) val responsePatch = client . patch ( \"/\" )","title":"Without body"},{"location":"http_client/#with-body","text":"1 2 3 4 5 6 7 8 9 10 val body = mapOf ( \"key\" to \"value\" ) val serializedBody = body . serialize () val responseGet = client . get ( \"/\" , body = serializedBody ) val responsePost = client . post ( \"/\" , serializedBody ) val responsePut = client . put ( \"/\" , serializedBody ) val responseDelete = client . delete ( \"/\" , serializedBody ) val responseTrace = client . trace ( \"/\" , serializedBody ) val responseOptions = client . options ( \"/\" , serializedBody ) val responsePatch = client . patch ( \"/\" , serializedBody )","title":"With body"},{"location":"http_client/#with-body-and-content-type","text":"1 2 3 4 5 6 7 8 9 10 val body = mapOf ( \"key\" to \"value\" ) val serializedBody = body . serialize ( YAML ) val responseGet = client . get ( \"/\" , body = serializedBody , contentType = ContentType ( YAML )) val responsePost = client . post ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responsePut = client . put ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responseDelete = client . delete ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responseTrace = client . trace ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responseOptions = client . options ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responsePatch = client . patch ( \"/\" , serializedBody , contentType = ContentType ( YAML ))","title":"With body and content type"},{"location":"http_client/#cookies","text":"The HTTP client support setting cookies from client side and updates them after any server request. Check the details in the following code fragment: 1 2 3 4 5 6 7 8 9 10 11 12 val cookieName = \"sampleCookie\" val cookieValue = \"sampleCookieValue\" // Set the cookie in the client client . cookies = client . cookies + HttpCookie ( cookieName , cookieValue ) // Assert that it is received in the server and change its value afterwards client . post ( \"/assertHasCookie?cookieName= $ cookieName \" ) client . post ( \"/addCookie?cookieName= $ cookieName &cookieValue= ${ cookieValue } _changed\" ) // Verify that the client cookie is updated assertEquals ( cookieValue + \"_changed\" , client . cookiesMap () [ cookieName ]?. value ) You can also check the full test for more details.","title":"Cookies"},{"location":"http_client/#multipart-forms-and-files","text":"Using the HTTP client you can send MIME multipart parts to the server. You can use it to post forms or files.","title":"Multipart (forms and files)"},{"location":"http_client/#forms","text":"1 2 val parts = listOf ( HttpPart ( \"name\" , \"value\" )) val response = client . send ( HttpClientRequest ( POST , path = \"/multipart\" , parts = parts ))","title":"Forms"},{"location":"http_client/#files","text":"1 2 3 val stream = URL ( \"classpath:assets/index.html\" ). readBytes () val parts = listOf ( HttpPart ( \"file\" , stream , \"index.html\" )) val response = client . send ( HttpClientRequest ( POST , path = \"/file\" , parts = parts ))","title":"Files"},{"location":"http_client/#tls","text":"The HTTP client supports server certificates (to use HTTPS and HTTP/2) and also client certificates (to be able to do mutual TLS). Key stores may have the JKS format (deprecated), or the newer PKCS12 format. To set up client/server certificates, you need to include SslSettings in your ClientSettings . In the sections below you can see how to configure these parameters.","title":"TLS"},{"location":"http_client/#key-store","text":"This store holds the identity certificate, this certificate is presented to the server by the client in the handshake for the server to authorize or deny the connection. The following code: 1 2 3 4 val keyStoreSettings = SslSettings ( keyStore = URL ( \"classpath:ssl/ $ identity \" ), keyStorePassword = identity . reversed () )","title":"Key Store"},{"location":"http_client/#trust-store","text":"This key store should include all the trusted certificates. Any certificate added as CA (certificate authority) makes the client trust any other certificate signed by them. However, you can also add standalone server certificates. 1 2 3 4 val trustStoreSettings = SslSettings ( trustStore = URL ( \"classpath:ssl/ $ trust \" ), trustStorePassword = trust . reversed () )","title":"Trust Store"},{"location":"http_client/#mutual-tls","text":"If you set up the identity (service's own certificate) and the trust store (CAs and servers trusted by the client), you will achieve double ended authentication (server authenticated by the client, and client authenticated by the server). You can see a complete example below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Key store files val identity = \"hexagonkt.p12\" val trust = \"trust.p12\" // Default passwords are file name reversed val keyStorePassword = identity . reversed () val trustStorePassword = trust . reversed () // Key stores can be set as URIs to classpath resources (the triple slash is needed) val keyStore = URL ( \"classpath:ssl/ $ identity \" ) val trustStore = URL ( \"classpath:ssl/ $ trust \" ) val sslSettings = SslSettings ( keyStore = keyStore , keyStorePassword = keyStorePassword , trustStore = trustStore , trustStorePassword = trustStorePassword , clientAuth = true // Requires a valid certificate from the client (mutual TLS) ) val serverSettings = HttpServerSettings ( bindPort = 0 , protocol = HTTPS , // You can also use HTTP2 sslSettings = sslSettings ) val server = HttpServer ( serverAdapter (), serverSettings ) { get ( \"/hello\" ) { // We can access the certificate used by the client from the request val subjectDn = request . certificate () ?. subjectX500Principal ?. name ?: \"\" val h = response . headers + ( \"cert\" to subjectDn ) ok ( \"Hello World!\" , headers = h ) } } server . start () // We'll use the same certificate for the client (in a real scenario it would be different) val clientSettings = HttpClientSettings ( sslSettings = sslSettings ) // Create an HTTP client and make an HTTPS request val contextPath = URL ( \"https://localhost: ${ server . runtimePort } \" ) val client = HttpClient ( clientAdapter (), contextPath , clientSettings ) client . start () client . get ( \"/hello\" ). apply { logger . debug { body } // Assure the certificate received (and returned) by the server is correct assert ( headers . require ( \"cert\" ). startsWith ( \"CN=hexagonkt.com\" )) assertEquals ( \"Hello World!\" , body ) }","title":"Mutual TLS"},{"location":"http_client/#package-comhexagonkthttpclient","text":"This package holds the classes that define the HTTP client and its configuration settings.","title":"Package com.hexagonkt.http.client"},{"location":"http_client/#package-comhexagonkthttpclientmodel","text":"TODO","title":"Package com.hexagonkt.http.client.model"},{"location":"http_client_jetty/","text":"Module http_client_jetty \u00b6 http_client implementation using the Jetty HTTP Client library. Install the Dependency \u00b6 build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } implementation ( \"com.hexagonkt:http_client_jetty:$hexagonVersion\" ) 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> http_client_jetty </artifactId> <version> $hexagonVersion </version> </dependency> Package com.hexagonkt.http.client.jetty \u00b6 Jetty HTTP client implementation classes.","title":"Module http_client_jetty"},{"location":"http_client_jetty/#module-http_client_jetty","text":"http_client implementation using the Jetty HTTP Client library.","title":"Module http_client_jetty"},{"location":"http_client_jetty/#install-the-dependency","text":"build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } implementation ( \"com.hexagonkt:http_client_jetty:$hexagonVersion\" ) 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> http_client_jetty </artifactId> <version> $hexagonVersion </version> </dependency>","title":"Install the Dependency"},{"location":"http_client_jetty/#package-comhexagonkthttpclientjetty","text":"Jetty HTTP client implementation classes.","title":"Package com.hexagonkt.http.client.jetty"},{"location":"http_server/","text":"Module http_server \u00b6 This port's purpose is to develop HTTP servers (REST services or Web applications). It defines a DSL to declare HTTP request handlers. Adapters implementing this port are in charge of transforming the DSL into a runtime. And allows you to switch implementations without changing the service. Install the Dependency \u00b6 This module is not meant to be used directly. You should include and Adapter implementing this feature (as http_server_jetty ) in order to create an HTTP server. Server \u00b6 A server is a process listening to HTTP requests on a TCP port. You can run multiple ones on different ports at the same time (this can be useful to test many microservices at the same time). The server can be configured with different properties. If you do not provide a value for them, they are searched inside the application settings and lastly, a default value is picked. This is the parameters list: banner: informative text shown at start up logs. If not set only runtime information is displayed. bindAddress: address to which this process is bound. If none is provided, 127.0.0.1 is taken. bindPort: the port which the process listens to. By default, it is 2010 . contextPath: initial path used for the rest of the routes, by default it is empty. To create a server, you need to provide a router (check the next section for more information), and after creating a server you can run it or stop it with start() and stop() methods. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* * All settings are optional, you can supply any combination * Parameters not set will fall back to the defaults */ val settings = HttpServerSettings ( bindAddress = InetAddress . getByName ( \"0.0.0\" ), bindPort = 2020 , contextPath = \"/context\" , banner = \"name\" ) val path = path { get ( \"/hello\" ) { ok ( \"Hello World!\" ) } } serve ( serverAdapter (), listOf ( path ), settings ). use { server -> HttpClient ( clientAdapter (), URL ( \"http://localhost: ${ server . runtimePort } \" )). use { it . start () assert ( server . started ()) assertEquals ( \"Hello World!\" , it . get ( \"/context/hello\" ). body ) } } /* * You can skip the adapter is you previously bound one * You may also skip the settings and the defaults will be used */ serve ( serverAdapter (), listOf ( path )). use { server -> HttpClient ( clientAdapter (), URL ( \"http://localhost: ${ server . runtimePort } \" )). use { it . start () assert ( server . started ()) assertEquals ( \"Hello World!\" , it . get ( \"/hello\" ). body ) } } Servlet Web server \u00b6 There is a special server adapter for running inside Servlet Containers. To use it you should import the Servlet HTTP Server Adapter into your project. Check the http_server_servlet module for more information. Routes \u00b6 The main building block of a Hexagon HTTP service is a set of routes. A route is made up of three simple pieces: A verb (get, post, put, delete, head, trace, connect, options). It can also be any . A path (/hello, /users/{name}). Paths must start with '/' and trailing slash is ignored. A callback code block. The callback has a void return type. You should use Call.send() to set the response which will be returned to the user. Routes are matched in the order they are defined. The first route that matches the request is invoked, and the following ones are ignored. Check the next snippet for usage examples: 1 2 3 4 5 6 7 get ( \"/hello\" ) { ok ( \"Get greeting\" ) } put ( \"/hello\" ) { ok ( \"Put greeting\" ) } post ( \"/hello\" ) { ok ( \"Post greeting\" ) } on ( ALL - GET - PUT - POST , \"/hello\" ) { ok ( \"Fallback if HTTP verb was not used before\" ) } on ( status = NOT_FOUND ) { ok ( \"Get at '/' if no route matched before\" ) } HTTP clients will be able to reuse the routes to create REST services clients. Route groups \u00b6 Routes can be nested by calling the path() method, which takes a String prefix and gives you a scope to declare routes and filters (or more nested paths). Ie: 1 2 3 4 5 6 7 8 9 path ( \"/nested\" ) { get ( \"/hello\" ) { ok ( \"Greeting\" ) } path ( \"/secondLevel\" ) { get ( \"/hello\" ) { ok ( \"Second level greeting\" ) } } get { ok ( \"Get at '/nested'\" ) } } Routers \u00b6 If you have a lot of routes, it can be helpful to group them into routers. You can create routers to mount a group of routes in different paths (allowing you to reuse them). Check this snippet: 1 2 3 4 5 6 7 8 9 10 fun personRouter ( kind : String ) = path { get { ok ( \"Get $ kind \" ) } put { ok ( \"Put $ kind \" ) } post { ok ( \"Post $ kind \" ) } } val server = HttpServer ( serverAdapter ()) { path ( \"/clients\" , personRouter ( \"client\" )) path ( \"/customers\" , personRouter ( \"customer\" )) } Callbacks \u00b6 Callbacks are request's handling blocks that are bound to routes or filters. They make the request, response and session objects available to the handling code. Call \u00b6 The Call object provides you with everything you need to handle a http-request. It contains the underlying request and response, and a bunch of utility methods to return results, read parameters or pass attributes among filters/routes. The methods are available directly from the callback ( Call is the callback receiver). You can check the API documentation for the full list of methods. This sample code illustrates the usage: 1 2 3 4 5 6 7 8 9 10 11 12 get ( \"/call\" ) { attributes // the attributes list attributes [ \"foo\" ] // value of foo attribute ok ( \"Response body\" ) // returns a 200 status // return any status send ( BAD_REQUEST , \"Invalid request\" , attributes = attributes + ( \"A\" to \"V\" ) // sets value of attribute A to V ) } Request \u00b6 Request functionality is provided by the request field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 get ( \"/request\" ) { // URL Information request . method // the HTTP method (GET, ..etc) request . protocol // http or https TODO request . host // the host, e.g. \"example.com\" request . port // the server port request . path // the request path, e.g. /result.jsp request . body // request body sent by the client method // Shortcut of `request.method` protocol // Shortcut of `request.protocol` host // Shortcut of `request.host` port // Shortcut of `request.port` path // Shortcut of `request.path` // Headers request . headers // the HTTP header list with first values only request . headers [ \"BAR\" ] // first value of BAR header request . headers . allValues // the HTTP header list with their full values list request . headers . allValues [ \"BAR\" ] // list of values of BAR header // Common headers shortcuts request . contentType // content type of request.body request . accept // Client accepted content types request . userAgent () // user agent (browser requests) request . origin () // origin (browser requests) request . referer () // TODO accept // Shortcut of `request.accept` // Parameters pathParameters // map with all path parameters request . formParameters // map with first values of all form fields request . formParameters . allValues // map with all form fields values request . queryParameters // map with first values of all query parameters request . queryParameters . allValues // map with all query parameters values queryParameters // Shortcut of `request.queryParameters` queryParameters . allValues // Shortcut of `request.queryParameters.allValues` formParameters // Shortcut of `request.formParameters` formParameters . allValues // Shortcut of `request.formParameters.allValues` // Body processing request . contentLength // length of request body ok () } Path Parameters \u00b6 Route patterns can include named parameters, accessible via the pathParameters map on the request object: 1 2 3 4 5 get ( \"/pathParam/{foo}\" ) { pathParameters [ \"foo\" ] // value of foo path parameter pathParameters // map with all parameters ok () } Query Parameters \u00b6 It is possible to access the whole query string or only a specific query parameter using the parameters map on the request object: 1 2 3 4 5 6 7 8 get ( \"/queryParam\" ) { request . queryParameters // the query param list request . queryParameters [ \"FOO\" ] // value of FOO query param request . queryParameters . allValues // the query param list request . queryParameters . allValues [ \"FOO\" ] // all values of FOO query param ok () } Form Parameters \u00b6 HTML Form processing. Don't parse body! 1 2 3 4 5 6 7 get ( \"/formParam\" ) { request . formParameters // the query param list request . formParameters [ \"FOO\" ] // value of FOO query param request . formParameters . allValues // the query param list request . formParameters . allValues [ \"FOO\" ] // all values of FOO query param ok () } File Uploads \u00b6 Multipart Requests 1 2 3 4 post ( \"/file\" ) { val filePart = request . partsMap () [ \"file\" ] ?: error ( \"File not available\" ) ok ( filePart . body ) } Response \u00b6 Response information is provided by the response field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 get ( \"/response\" ) { response . body // get response content response . status // get the response status response . contentType // get the content type status // Shortcut of `response.status` send ( status = UNAUTHORIZED , // set status code to 401 body = \"Hello\" , // sets content to Hello contentType = ContentType ( XML ), // set content type to application/xml headers = response . headers + ( \"foo\" to \"bar\" ) // sets header FOO with single value bar + multiMapOfLists ( \"baz\" to listOf ( \"1\" , \"2\" )) // sets header FOO values with [ bar ] ) } Redirects \u00b6 You can redirect requests (returning 30x codes) by using Call utility methods: 1 2 3 get ( \"/redirect\" ) { redirect ( FOUND , \"/call\" ) // browser redirect to /call } Cookies \u00b6 The request and response cookie functions provide a convenient way for sharing information between handlers, requests, or even servers. You can read client sent cookies from the request's cookies read only map. To change cookies or add new ones you have to use response.addCookie() and response.removeCookie() methods. Check the following sample code for details: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 get ( \"/cookie\" ) { request . cookies // get map of all request cookies request . cookiesMap () [ \"foo\" ] // access request cookie by name val cookie = HttpCookie ( \"new_foo\" , \"bar\" ) ok ( cookies = listOf ( cookie , // set cookie with a value cookie . copy ( maxAge = 3600 ), // set cookie with a max-age cookie . copy ( secure = true ), // secure cookie cookie . delete (), // remove cookie ) ) } Sessions \u00b6 Every request has access to the session created on the server side, the session object provides the following methods: 1 Compression \u00b6 Halting \u00b6 To immediately stop a request within a filter or route use halt() . halt() is not intended to be used inside exception-mappers. Check the following snippet for an example: 1 2 3 4 5 6 get ( \"/halt\" ) { clientError ( UNAUTHORIZED ) // halt with status clientError ( UNAUTHORIZED , \"Go away!\" ) // halt with status and message internalServerError ( \"Body Message\" ) // halt with message (status 500) internalServerError () // halt with status 500 } Filters \u00b6 You might know filters as interceptors, or middleware from other libraries. Filters are blocks of code executed before or after one or more routes. They can read the request and read/modify the response. All filters that match a route are executed in the order they are declared. Filters optionally take a pattern, causing them to be executed only if the request path matches that pattern. Before and after filters are always executed (if the route is matched). However, any of them may stop the execution chain if halted. If halt() is called in one filter, filter processing is stopped for that kind of filter ( before or after ). In the case of before filters, this also prevent the route from being executed (but after filters are executed anyway). The following code details filters usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 on ( \"/*\" ) { send ( headers = response . headers + ( \"b-all\" to \"true\" )) } on ( \"/filters/*\" ) { send ( headers = response . headers + ( \"b-filters\" to \"true\" )) } get ( \"/filters/route\" ) { ok ( \"filters route\" ) } after ( \"/filters/*\" ) { send ( headers = response . headers + ( \"a-filters\" to \"true\" )) } get ( \"/filters\" ) { ok ( \"filters\" ) } path ( \"/nested\" ) { on ( \"*\" ) { send ( headers = response . headers + ( \"b-nested\" to \"true\" )) } on { send ( headers = response . headers + ( \"b-nested-2\" to \"true\" )) } get ( \"/filters\" ) { ok ( \"nested filters\" ) } get ( \"/halted\" ) { send ( HttpStatus ( 499 ), \"halted\" ) } get { ok ( \"nested also\" ) } after ( \"*\" ) { send ( headers = response . headers + ( \"a-nested\" to \"true\" )) } } after ( \"/*\" ) { send ( headers = response . headers + ( \"a-all\" to \"true\" )) } Error Handling \u00b6 You can provide handlers for runtime errors. Errors are unhandled thrown exceptions in the callbacks, or handlers halted with an error code. Error handlers for a given code or exception are unique, and the first one defined is the one which will be used. HTTP Errors Handlers \u00b6 Allows handling routes halted with a given code. These handlers are only applied if the route is halted, if the error code is returned with send it won't be handled as an error. Example: 1 2 3 4 5 6 7 8 exception < Exception > ( NOT_FOUND ) { internalServerError ( \"Root handler\" ) } // Register handler for routes halted with 512 code get ( \"/errors\" ) { send ( HttpStatus ( 512 )) } on ( pattern = \"*\" , status = HttpStatus ( 512 )) { send ( INTERNAL_SERVER_ERROR , \"Ouch\" ) } Exception Mapping \u00b6 You can handle exceptions of a given type for all routes and filters. The handler allows you to refer to the thrown exception. Look at the following code for a detailed example: 1 2 3 4 5 6 7 8 9 10 // Register handler for routes which callbacks throw exceptions get ( \"/exceptions\" ) { error ( \"Message\" ) } get ( \"/codedExceptions\" ) { send ( HttpStatus ( 509 ), \"code\" ) } on ( pattern = \"*\" , status = HttpStatus ( 509 )) { send ( HttpStatus ( 599 )) } on ( pattern = \"*\" , exception = IllegalStateException :: class ) { send ( HTTP_VERSION_NOT_SUPPORTED , exception ?. message ?: \"empty\" ) } Static Files \u00b6 You can use a folder in the classpath for serving static files with the get() methods. Note that the public directory name is not included in the URL. Asset mapping is handled like any other route, so if an asset mapping is matched, no other route will be checked (assets or other routes). Also, if a previous route is matched, the asset mapping will never be checked. Being get(resource) a shortcut of get(\"/*\", resource) it should be placed as the last route. Check the next example for details: 1 2 3 4 5 6 7 8 9 10 11 12 get ( \"/web/file.txt\" ) { ok ( \"It matches this route and won't search for the file\" ) } // Expose resources on the '/public' resource folder over the '/web' HTTP path on ( status = NOT_FOUND , pattern = \"/web/*\" , callback = UrlCallback ( URL ( \"classpath:public\" )) ) // Maps resources on 'assets' on the server root (assets/f.css -> /f.css) // '/public/css/style.css' resource would be: 'http://{host}:{port}/css/style.css' on ( status = NOT_FOUND , pattern = \"/*\" , callback = UrlCallback ( URL ( \"classpath:assets\" ))) MIME types \u00b6 The MIME types of static files are computed from the file extension using the SerializationManager.contentTypeOf() method. CORS \u00b6 CORS behaviour can be different depending on the path. You can attach different CorsSettings to different routers. Check CorsSettings class for more details. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 val path : PathHandler = path { corsPath ( \"/default\" , CorsCallback ()) corsPath ( \"/example/org\" , CorsCallback ( \"example.org\" )) corsPath ( \"/no/credentials\" , CorsCallback ( supportCredentials = false )) corsPath ( \"/only/post\" , CorsCallback ( allowedMethods = setOf ( POST ))) corsPath ( \"/cache\" , CorsCallback ( preFlightMaxAge = 10 )) corsPath ( \"/exposed/headers\" , CorsCallback ( exposedHeaders = setOf ( \"head\" ))) corsPath ( \"/allowed/headers\" , CorsCallback ( allowedHeaders = setOf ( \"head\" ))) } private fun ServerBuilder . corsPath ( path : String , cors : CorsCallback ) { path ( path ) { // CORS settings can change for different routes filter ( pattern = \"*\" , callback = cors ) get ( \"/path\" ) { ok ( method . toString ()) } post ( \"/path\" ) { ok ( method . toString ()) } put ( \"/path\" ) { ok ( method . toString ()) } delete ( \"/path\" ) { ok ( method . toString ()) } get { ok ( method . toString ()) } post { ok ( method . toString ()) } put { ok ( method . toString ()) } delete { ok ( method . toString ()) } } } HTTPS \u00b6 It is possible to start a secure server enabling HTTPS. For this, you have to provide a server certificate and its key in the server's SslSettings . Once you use a server certificate, it is also possible to serve content using HTTP/2 , for this to work, ALPN is required (however, this is already handled if you use Java 11). The certificate common name should match the host that will serve the content in order to be accepted by an HTTP client without a security error. There is a Gradle helper to create sample certificates for development purposes. HTTP clients can also be configured to use a certificate. This is required to implement a double ended authorization ( mutual TLS ). This is also done by passing a SslSettings object the HTTP client. If you want to implement mutual trust, you must enforce client certificate in the server configuration (check SslSettings.clientAuth ). If this is done, you can access the certificate the client used to connect (assuming it is valid, if not the connection will end with an error) with the Request.certificateChain property. Below you can find a simple example to set up an HTTPS server and client with mutual TLS: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Key store files val identity = \"hexagonkt.p12\" val trust = \"trust.p12\" // Default passwords are file name reversed val keyStorePassword = identity . reversed () val trustStorePassword = trust . reversed () // Key stores can be set as URIs to classpath resources (the triple slash is needed) val keyStore = URL ( \"classpath:ssl/ $ identity \" ) val trustStore = URL ( \"classpath:ssl/ $ trust \" ) val sslSettings = SslSettings ( keyStore = keyStore , keyStorePassword = keyStorePassword , trustStore = trustStore , trustStorePassword = trustStorePassword , clientAuth = true // Requires a valid certificate from the client (mutual TLS) ) val serverSettings = HttpServerSettings ( bindPort = 0 , protocol = HTTPS , // You can also use HTTP2 sslSettings = sslSettings ) val server = HttpServer ( serverAdapter (), serverSettings ) { get ( \"/hello\" ) { // We can access the certificate used by the client from the request val subjectDn = request . certificate () ?. subjectX500Principal ?. name ?: \"\" val h = response . headers + ( \"cert\" to subjectDn ) ok ( \"Hello World!\" , headers = h ) } } server . start () // We'll use the same certificate for the client (in a real scenario it would be different) val clientSettings = HttpClientSettings ( sslSettings = sslSettings ) // Create an HTTP client and make an HTTPS request val contextPath = URL ( \"https://localhost: ${ server . runtimePort } \" ) val client = HttpClient ( clientAdapter (), contextPath , clientSettings ) client . start () client . get ( \"/hello\" ). apply { logger . debug { body } // Assure the certificate received (and returned) by the server is correct assert ( headers . require ( \"cert\" ). startsWith ( \"CN=hexagonkt.com\" )) assertEquals ( \"Hello World!\" , body ) } Testing \u00b6 Integration tests \u00b6 To test HTTP servers from outside using a real Adapter, you can create a server setting 0 as port. This will pick a random free port which you can check later: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 val router = path { get ( \"/hello\" ) { ok ( \"Hi!\" ) } } val bindAddress = InetAddress . getLoopbackAddress () val serverSettings = HttpServerSettings ( bindAddress , 0 , banner = \"name\" ) val server = serve ( serverAdapter (), listOf ( router ), serverSettings ) server . use { s -> HttpClient ( clientAdapter (), URL ( \"http://localhost: ${ s . runtimePort } \" )). use { it . start () assertEquals ( \"Hi!\" , it . get ( \"/hello\" ). body ) } } To do this kind of tests without creating a custom server (using the real production code). Check the tests of the starter projects . If you have an OpenAPI/Swagger spec defined for your server, you can also make use of the mock server ( see below ). Mocking calls \u00b6 To unit test callbacks you can create test calls with hardcoded requests, responses and sessions. To use it in your project you'll have to include a dependency (with test scope): build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } testImplementation ( \"com.hexagonkt:http_server:$hexagonVersion:test\" ) 1 2 3 4 5 6 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> http_server </artifactId> <version> $hexagonVersion </version> <scope> test </scope> </dependency> Check testCall , TestRequest , TestResponse and TestSession for more details. For a quick sample, check the snipped below: TODO Add example code OpenAPI Mock Server \u00b6 The mock server is able to create and return a Server from the information of an OpenAPI/Swagger spec file. The path to the spec file can either be a URL or a local file. It can be either in JSON or YAML format. The mock server takes all its data from the spec and the request and response of the routes is determined by the routes' examples and schemas. During handling of a request, the mock server validates the request parameters against those specified in the spec file and returns an appropriate response from the provided examples . If any authentication requirements are specified, they are validated as well. How to Use \u00b6 First, add the required dependencies: 1 2 implementation ( \"com.hexagonkt:http_server: $ hexagonVersion :test\" ) implementation ( \"io.swagger.parser.v3:swagger-parser: $ swaggerParserVersion \" ) To create the mock server object: 1 val mockServer = MockServer ( \"https://petstore3.swagger.io/api/v3/openapi.json\" ) Optionally, you can also explicitly specify a port number: 1 val mockServer = MockServer ( \"https://petstore3.swagger.io/api/v3/openapi.json\" , port = 9090 ) To get the actual server object: 1 val server = mockServer . server Finally, to run the server: 1 server . start () OpenAPI Spec File Requirements \u00b6 The file provided should be a syntactically valid OpenAPI spec file. If it is not, an error will be raised at initialization time. For each path in the spec file, descriptions for 200 and 400 (in case parameter verification fails) status codes must be provided. If the path contains authentication requirements, a 401 status code description must also be provided. In addition, for each status code, at least one example must be provided. Note that, at present, only the application/json media type is supported. Supported Authentication Methods \u00b6 Currently, the following Authentication methods/mechanisms are supported: API Key authentication (key may be present in the headers, query parameters or cookies) HTTP Authentication (Basic or Bearer authentication) Providing Examples \u00b6 There are several ways to define response examples in an OpenAPI spec file. If there are multiple examples defined for a particular path status code, you can specify a particular response by using the X-Mock-Response-Example header with the name of the desired example. The mock server follows the following priority order when parsing the spec file for examples: If the X-Mock-Response-Example header is present, then the example corresponding to the value of that header is immediately fetched and returned. If no X-Mock-Response-Example header is present, it first tries to fetch an example from the schema key within the media type object. If no example is found here, it then attempts to fetch the example from the example key in the media type object. Next, it attempts to fetch the first value found in the examples key of the media type object. If still no example is found, it simply raises an exception. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \"content\" : { \"application/json\" : { \"schema\" : { \"example\" : \"This value is checked first\" }, \"example\" : \"This value is checked second\" , \"examples\" : { \"example1\" : { \"value\" : \"This value is checked third\" }, \"example2\" : { \"value\" : \"This value would be returned if the X-Mock-Response-Example header is passed with value 'example2'\" } } } } Package com.hexagonkt.http.server \u00b6 This package defines the classes used in the HTTP DSL. Package com.hexagonkt.http.server.callbacks \u00b6 TODO Package com.hexagonkt.http.server.handlers \u00b6 TODO Package com.hexagonkt.http.server.model \u00b6 TODO","title":"HTTP Server"},{"location":"http_server/#module-http_server","text":"This port's purpose is to develop HTTP servers (REST services or Web applications). It defines a DSL to declare HTTP request handlers. Adapters implementing this port are in charge of transforming the DSL into a runtime. And allows you to switch implementations without changing the service.","title":"Module http_server"},{"location":"http_server/#install-the-dependency","text":"This module is not meant to be used directly. You should include and Adapter implementing this feature (as http_server_jetty ) in order to create an HTTP server.","title":"Install the Dependency"},{"location":"http_server/#server","text":"A server is a process listening to HTTP requests on a TCP port. You can run multiple ones on different ports at the same time (this can be useful to test many microservices at the same time). The server can be configured with different properties. If you do not provide a value for them, they are searched inside the application settings and lastly, a default value is picked. This is the parameters list: banner: informative text shown at start up logs. If not set only runtime information is displayed. bindAddress: address to which this process is bound. If none is provided, 127.0.0.1 is taken. bindPort: the port which the process listens to. By default, it is 2010 . contextPath: initial path used for the rest of the routes, by default it is empty. To create a server, you need to provide a router (check the next section for more information), and after creating a server you can run it or stop it with start() and stop() methods. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* * All settings are optional, you can supply any combination * Parameters not set will fall back to the defaults */ val settings = HttpServerSettings ( bindAddress = InetAddress . getByName ( \"0.0.0\" ), bindPort = 2020 , contextPath = \"/context\" , banner = \"name\" ) val path = path { get ( \"/hello\" ) { ok ( \"Hello World!\" ) } } serve ( serverAdapter (), listOf ( path ), settings ). use { server -> HttpClient ( clientAdapter (), URL ( \"http://localhost: ${ server . runtimePort } \" )). use { it . start () assert ( server . started ()) assertEquals ( \"Hello World!\" , it . get ( \"/context/hello\" ). body ) } } /* * You can skip the adapter is you previously bound one * You may also skip the settings and the defaults will be used */ serve ( serverAdapter (), listOf ( path )). use { server -> HttpClient ( clientAdapter (), URL ( \"http://localhost: ${ server . runtimePort } \" )). use { it . start () assert ( server . started ()) assertEquals ( \"Hello World!\" , it . get ( \"/hello\" ). body ) } }","title":"Server"},{"location":"http_server/#servlet-web-server","text":"There is a special server adapter for running inside Servlet Containers. To use it you should import the Servlet HTTP Server Adapter into your project. Check the http_server_servlet module for more information.","title":"Servlet Web server"},{"location":"http_server/#routes","text":"The main building block of a Hexagon HTTP service is a set of routes. A route is made up of three simple pieces: A verb (get, post, put, delete, head, trace, connect, options). It can also be any . A path (/hello, /users/{name}). Paths must start with '/' and trailing slash is ignored. A callback code block. The callback has a void return type. You should use Call.send() to set the response which will be returned to the user. Routes are matched in the order they are defined. The first route that matches the request is invoked, and the following ones are ignored. Check the next snippet for usage examples: 1 2 3 4 5 6 7 get ( \"/hello\" ) { ok ( \"Get greeting\" ) } put ( \"/hello\" ) { ok ( \"Put greeting\" ) } post ( \"/hello\" ) { ok ( \"Post greeting\" ) } on ( ALL - GET - PUT - POST , \"/hello\" ) { ok ( \"Fallback if HTTP verb was not used before\" ) } on ( status = NOT_FOUND ) { ok ( \"Get at '/' if no route matched before\" ) } HTTP clients will be able to reuse the routes to create REST services clients.","title":"Routes"},{"location":"http_server/#route-groups","text":"Routes can be nested by calling the path() method, which takes a String prefix and gives you a scope to declare routes and filters (or more nested paths). Ie: 1 2 3 4 5 6 7 8 9 path ( \"/nested\" ) { get ( \"/hello\" ) { ok ( \"Greeting\" ) } path ( \"/secondLevel\" ) { get ( \"/hello\" ) { ok ( \"Second level greeting\" ) } } get { ok ( \"Get at '/nested'\" ) } }","title":"Route groups"},{"location":"http_server/#routers","text":"If you have a lot of routes, it can be helpful to group them into routers. You can create routers to mount a group of routes in different paths (allowing you to reuse them). Check this snippet: 1 2 3 4 5 6 7 8 9 10 fun personRouter ( kind : String ) = path { get { ok ( \"Get $ kind \" ) } put { ok ( \"Put $ kind \" ) } post { ok ( \"Post $ kind \" ) } } val server = HttpServer ( serverAdapter ()) { path ( \"/clients\" , personRouter ( \"client\" )) path ( \"/customers\" , personRouter ( \"customer\" )) }","title":"Routers"},{"location":"http_server/#callbacks","text":"Callbacks are request's handling blocks that are bound to routes or filters. They make the request, response and session objects available to the handling code.","title":"Callbacks"},{"location":"http_server/#call","text":"The Call object provides you with everything you need to handle a http-request. It contains the underlying request and response, and a bunch of utility methods to return results, read parameters or pass attributes among filters/routes. The methods are available directly from the callback ( Call is the callback receiver). You can check the API documentation for the full list of methods. This sample code illustrates the usage: 1 2 3 4 5 6 7 8 9 10 11 12 get ( \"/call\" ) { attributes // the attributes list attributes [ \"foo\" ] // value of foo attribute ok ( \"Response body\" ) // returns a 200 status // return any status send ( BAD_REQUEST , \"Invalid request\" , attributes = attributes + ( \"A\" to \"V\" ) // sets value of attribute A to V ) }","title":"Call"},{"location":"http_server/#request","text":"Request functionality is provided by the request field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 get ( \"/request\" ) { // URL Information request . method // the HTTP method (GET, ..etc) request . protocol // http or https TODO request . host // the host, e.g. \"example.com\" request . port // the server port request . path // the request path, e.g. /result.jsp request . body // request body sent by the client method // Shortcut of `request.method` protocol // Shortcut of `request.protocol` host // Shortcut of `request.host` port // Shortcut of `request.port` path // Shortcut of `request.path` // Headers request . headers // the HTTP header list with first values only request . headers [ \"BAR\" ] // first value of BAR header request . headers . allValues // the HTTP header list with their full values list request . headers . allValues [ \"BAR\" ] // list of values of BAR header // Common headers shortcuts request . contentType // content type of request.body request . accept // Client accepted content types request . userAgent () // user agent (browser requests) request . origin () // origin (browser requests) request . referer () // TODO accept // Shortcut of `request.accept` // Parameters pathParameters // map with all path parameters request . formParameters // map with first values of all form fields request . formParameters . allValues // map with all form fields values request . queryParameters // map with first values of all query parameters request . queryParameters . allValues // map with all query parameters values queryParameters // Shortcut of `request.queryParameters` queryParameters . allValues // Shortcut of `request.queryParameters.allValues` formParameters // Shortcut of `request.formParameters` formParameters . allValues // Shortcut of `request.formParameters.allValues` // Body processing request . contentLength // length of request body ok () }","title":"Request"},{"location":"http_server/#path-parameters","text":"Route patterns can include named parameters, accessible via the pathParameters map on the request object: 1 2 3 4 5 get ( \"/pathParam/{foo}\" ) { pathParameters [ \"foo\" ] // value of foo path parameter pathParameters // map with all parameters ok () }","title":"Path Parameters"},{"location":"http_server/#query-parameters","text":"It is possible to access the whole query string or only a specific query parameter using the parameters map on the request object: 1 2 3 4 5 6 7 8 get ( \"/queryParam\" ) { request . queryParameters // the query param list request . queryParameters [ \"FOO\" ] // value of FOO query param request . queryParameters . allValues // the query param list request . queryParameters . allValues [ \"FOO\" ] // all values of FOO query param ok () }","title":"Query Parameters"},{"location":"http_server/#form-parameters","text":"HTML Form processing. Don't parse body! 1 2 3 4 5 6 7 get ( \"/formParam\" ) { request . formParameters // the query param list request . formParameters [ \"FOO\" ] // value of FOO query param request . formParameters . allValues // the query param list request . formParameters . allValues [ \"FOO\" ] // all values of FOO query param ok () }","title":"Form Parameters"},{"location":"http_server/#file-uploads","text":"Multipart Requests 1 2 3 4 post ( \"/file\" ) { val filePart = request . partsMap () [ \"file\" ] ?: error ( \"File not available\" ) ok ( filePart . body ) }","title":"File Uploads"},{"location":"http_server/#response","text":"Response information is provided by the response field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 get ( \"/response\" ) { response . body // get response content response . status // get the response status response . contentType // get the content type status // Shortcut of `response.status` send ( status = UNAUTHORIZED , // set status code to 401 body = \"Hello\" , // sets content to Hello contentType = ContentType ( XML ), // set content type to application/xml headers = response . headers + ( \"foo\" to \"bar\" ) // sets header FOO with single value bar + multiMapOfLists ( \"baz\" to listOf ( \"1\" , \"2\" )) // sets header FOO values with [ bar ] ) }","title":"Response"},{"location":"http_server/#redirects","text":"You can redirect requests (returning 30x codes) by using Call utility methods: 1 2 3 get ( \"/redirect\" ) { redirect ( FOUND , \"/call\" ) // browser redirect to /call }","title":"Redirects"},{"location":"http_server/#cookies","text":"The request and response cookie functions provide a convenient way for sharing information between handlers, requests, or even servers. You can read client sent cookies from the request's cookies read only map. To change cookies or add new ones you have to use response.addCookie() and response.removeCookie() methods. Check the following sample code for details: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 get ( \"/cookie\" ) { request . cookies // get map of all request cookies request . cookiesMap () [ \"foo\" ] // access request cookie by name val cookie = HttpCookie ( \"new_foo\" , \"bar\" ) ok ( cookies = listOf ( cookie , // set cookie with a value cookie . copy ( maxAge = 3600 ), // set cookie with a max-age cookie . copy ( secure = true ), // secure cookie cookie . delete (), // remove cookie ) ) }","title":"Cookies"},{"location":"http_server/#sessions","text":"Every request has access to the session created on the server side, the session object provides the following methods: 1","title":"Sessions"},{"location":"http_server/#compression","text":"","title":"Compression"},{"location":"http_server/#halting","text":"To immediately stop a request within a filter or route use halt() . halt() is not intended to be used inside exception-mappers. Check the following snippet for an example: 1 2 3 4 5 6 get ( \"/halt\" ) { clientError ( UNAUTHORIZED ) // halt with status clientError ( UNAUTHORIZED , \"Go away!\" ) // halt with status and message internalServerError ( \"Body Message\" ) // halt with message (status 500) internalServerError () // halt with status 500 }","title":"Halting"},{"location":"http_server/#filters","text":"You might know filters as interceptors, or middleware from other libraries. Filters are blocks of code executed before or after one or more routes. They can read the request and read/modify the response. All filters that match a route are executed in the order they are declared. Filters optionally take a pattern, causing them to be executed only if the request path matches that pattern. Before and after filters are always executed (if the route is matched). However, any of them may stop the execution chain if halted. If halt() is called in one filter, filter processing is stopped for that kind of filter ( before or after ). In the case of before filters, this also prevent the route from being executed (but after filters are executed anyway). The following code details filters usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 on ( \"/*\" ) { send ( headers = response . headers + ( \"b-all\" to \"true\" )) } on ( \"/filters/*\" ) { send ( headers = response . headers + ( \"b-filters\" to \"true\" )) } get ( \"/filters/route\" ) { ok ( \"filters route\" ) } after ( \"/filters/*\" ) { send ( headers = response . headers + ( \"a-filters\" to \"true\" )) } get ( \"/filters\" ) { ok ( \"filters\" ) } path ( \"/nested\" ) { on ( \"*\" ) { send ( headers = response . headers + ( \"b-nested\" to \"true\" )) } on { send ( headers = response . headers + ( \"b-nested-2\" to \"true\" )) } get ( \"/filters\" ) { ok ( \"nested filters\" ) } get ( \"/halted\" ) { send ( HttpStatus ( 499 ), \"halted\" ) } get { ok ( \"nested also\" ) } after ( \"*\" ) { send ( headers = response . headers + ( \"a-nested\" to \"true\" )) } } after ( \"/*\" ) { send ( headers = response . headers + ( \"a-all\" to \"true\" )) }","title":"Filters"},{"location":"http_server/#error-handling","text":"You can provide handlers for runtime errors. Errors are unhandled thrown exceptions in the callbacks, or handlers halted with an error code. Error handlers for a given code or exception are unique, and the first one defined is the one which will be used.","title":"Error Handling"},{"location":"http_server/#http-errors-handlers","text":"Allows handling routes halted with a given code. These handlers are only applied if the route is halted, if the error code is returned with send it won't be handled as an error. Example: 1 2 3 4 5 6 7 8 exception < Exception > ( NOT_FOUND ) { internalServerError ( \"Root handler\" ) } // Register handler for routes halted with 512 code get ( \"/errors\" ) { send ( HttpStatus ( 512 )) } on ( pattern = \"*\" , status = HttpStatus ( 512 )) { send ( INTERNAL_SERVER_ERROR , \"Ouch\" ) }","title":"HTTP Errors Handlers"},{"location":"http_server/#exception-mapping","text":"You can handle exceptions of a given type for all routes and filters. The handler allows you to refer to the thrown exception. Look at the following code for a detailed example: 1 2 3 4 5 6 7 8 9 10 // Register handler for routes which callbacks throw exceptions get ( \"/exceptions\" ) { error ( \"Message\" ) } get ( \"/codedExceptions\" ) { send ( HttpStatus ( 509 ), \"code\" ) } on ( pattern = \"*\" , status = HttpStatus ( 509 )) { send ( HttpStatus ( 599 )) } on ( pattern = \"*\" , exception = IllegalStateException :: class ) { send ( HTTP_VERSION_NOT_SUPPORTED , exception ?. message ?: \"empty\" ) }","title":"Exception Mapping"},{"location":"http_server/#static-files","text":"You can use a folder in the classpath for serving static files with the get() methods. Note that the public directory name is not included in the URL. Asset mapping is handled like any other route, so if an asset mapping is matched, no other route will be checked (assets or other routes). Also, if a previous route is matched, the asset mapping will never be checked. Being get(resource) a shortcut of get(\"/*\", resource) it should be placed as the last route. Check the next example for details: 1 2 3 4 5 6 7 8 9 10 11 12 get ( \"/web/file.txt\" ) { ok ( \"It matches this route and won't search for the file\" ) } // Expose resources on the '/public' resource folder over the '/web' HTTP path on ( status = NOT_FOUND , pattern = \"/web/*\" , callback = UrlCallback ( URL ( \"classpath:public\" )) ) // Maps resources on 'assets' on the server root (assets/f.css -> /f.css) // '/public/css/style.css' resource would be: 'http://{host}:{port}/css/style.css' on ( status = NOT_FOUND , pattern = \"/*\" , callback = UrlCallback ( URL ( \"classpath:assets\" )))","title":"Static Files"},{"location":"http_server/#mime-types","text":"The MIME types of static files are computed from the file extension using the SerializationManager.contentTypeOf() method.","title":"MIME types"},{"location":"http_server/#cors","text":"CORS behaviour can be different depending on the path. You can attach different CorsSettings to different routers. Check CorsSettings class for more details. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 val path : PathHandler = path { corsPath ( \"/default\" , CorsCallback ()) corsPath ( \"/example/org\" , CorsCallback ( \"example.org\" )) corsPath ( \"/no/credentials\" , CorsCallback ( supportCredentials = false )) corsPath ( \"/only/post\" , CorsCallback ( allowedMethods = setOf ( POST ))) corsPath ( \"/cache\" , CorsCallback ( preFlightMaxAge = 10 )) corsPath ( \"/exposed/headers\" , CorsCallback ( exposedHeaders = setOf ( \"head\" ))) corsPath ( \"/allowed/headers\" , CorsCallback ( allowedHeaders = setOf ( \"head\" ))) } private fun ServerBuilder . corsPath ( path : String , cors : CorsCallback ) { path ( path ) { // CORS settings can change for different routes filter ( pattern = \"*\" , callback = cors ) get ( \"/path\" ) { ok ( method . toString ()) } post ( \"/path\" ) { ok ( method . toString ()) } put ( \"/path\" ) { ok ( method . toString ()) } delete ( \"/path\" ) { ok ( method . toString ()) } get { ok ( method . toString ()) } post { ok ( method . toString ()) } put { ok ( method . toString ()) } delete { ok ( method . toString ()) } } }","title":"CORS"},{"location":"http_server/#https","text":"It is possible to start a secure server enabling HTTPS. For this, you have to provide a server certificate and its key in the server's SslSettings . Once you use a server certificate, it is also possible to serve content using HTTP/2 , for this to work, ALPN is required (however, this is already handled if you use Java 11). The certificate common name should match the host that will serve the content in order to be accepted by an HTTP client without a security error. There is a Gradle helper to create sample certificates for development purposes. HTTP clients can also be configured to use a certificate. This is required to implement a double ended authorization ( mutual TLS ). This is also done by passing a SslSettings object the HTTP client. If you want to implement mutual trust, you must enforce client certificate in the server configuration (check SslSettings.clientAuth ). If this is done, you can access the certificate the client used to connect (assuming it is valid, if not the connection will end with an error) with the Request.certificateChain property. Below you can find a simple example to set up an HTTPS server and client with mutual TLS: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Key store files val identity = \"hexagonkt.p12\" val trust = \"trust.p12\" // Default passwords are file name reversed val keyStorePassword = identity . reversed () val trustStorePassword = trust . reversed () // Key stores can be set as URIs to classpath resources (the triple slash is needed) val keyStore = URL ( \"classpath:ssl/ $ identity \" ) val trustStore = URL ( \"classpath:ssl/ $ trust \" ) val sslSettings = SslSettings ( keyStore = keyStore , keyStorePassword = keyStorePassword , trustStore = trustStore , trustStorePassword = trustStorePassword , clientAuth = true // Requires a valid certificate from the client (mutual TLS) ) val serverSettings = HttpServerSettings ( bindPort = 0 , protocol = HTTPS , // You can also use HTTP2 sslSettings = sslSettings ) val server = HttpServer ( serverAdapter (), serverSettings ) { get ( \"/hello\" ) { // We can access the certificate used by the client from the request val subjectDn = request . certificate () ?. subjectX500Principal ?. name ?: \"\" val h = response . headers + ( \"cert\" to subjectDn ) ok ( \"Hello World!\" , headers = h ) } } server . start () // We'll use the same certificate for the client (in a real scenario it would be different) val clientSettings = HttpClientSettings ( sslSettings = sslSettings ) // Create an HTTP client and make an HTTPS request val contextPath = URL ( \"https://localhost: ${ server . runtimePort } \" ) val client = HttpClient ( clientAdapter (), contextPath , clientSettings ) client . start () client . get ( \"/hello\" ). apply { logger . debug { body } // Assure the certificate received (and returned) by the server is correct assert ( headers . require ( \"cert\" ). startsWith ( \"CN=hexagonkt.com\" )) assertEquals ( \"Hello World!\" , body ) }","title":"HTTPS"},{"location":"http_server/#testing","text":"","title":"Testing"},{"location":"http_server/#integration-tests","text":"To test HTTP servers from outside using a real Adapter, you can create a server setting 0 as port. This will pick a random free port which you can check later: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 val router = path { get ( \"/hello\" ) { ok ( \"Hi!\" ) } } val bindAddress = InetAddress . getLoopbackAddress () val serverSettings = HttpServerSettings ( bindAddress , 0 , banner = \"name\" ) val server = serve ( serverAdapter (), listOf ( router ), serverSettings ) server . use { s -> HttpClient ( clientAdapter (), URL ( \"http://localhost: ${ s . runtimePort } \" )). use { it . start () assertEquals ( \"Hi!\" , it . get ( \"/hello\" ). body ) } } To do this kind of tests without creating a custom server (using the real production code). Check the tests of the starter projects . If you have an OpenAPI/Swagger spec defined for your server, you can also make use of the mock server ( see below ).","title":"Integration tests"},{"location":"http_server/#mocking-calls","text":"To unit test callbacks you can create test calls with hardcoded requests, responses and sessions. To use it in your project you'll have to include a dependency (with test scope): build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } testImplementation ( \"com.hexagonkt:http_server:$hexagonVersion:test\" ) 1 2 3 4 5 6 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> http_server </artifactId> <version> $hexagonVersion </version> <scope> test </scope> </dependency> Check testCall , TestRequest , TestResponse and TestSession for more details. For a quick sample, check the snipped below: TODO Add example code","title":"Mocking calls"},{"location":"http_server/#openapi-mock-server","text":"The mock server is able to create and return a Server from the information of an OpenAPI/Swagger spec file. The path to the spec file can either be a URL or a local file. It can be either in JSON or YAML format. The mock server takes all its data from the spec and the request and response of the routes is determined by the routes' examples and schemas. During handling of a request, the mock server validates the request parameters against those specified in the spec file and returns an appropriate response from the provided examples . If any authentication requirements are specified, they are validated as well.","title":"OpenAPI Mock Server"},{"location":"http_server/#how-to-use","text":"First, add the required dependencies: 1 2 implementation ( \"com.hexagonkt:http_server: $ hexagonVersion :test\" ) implementation ( \"io.swagger.parser.v3:swagger-parser: $ swaggerParserVersion \" ) To create the mock server object: 1 val mockServer = MockServer ( \"https://petstore3.swagger.io/api/v3/openapi.json\" ) Optionally, you can also explicitly specify a port number: 1 val mockServer = MockServer ( \"https://petstore3.swagger.io/api/v3/openapi.json\" , port = 9090 ) To get the actual server object: 1 val server = mockServer . server Finally, to run the server: 1 server . start ()","title":"How to Use"},{"location":"http_server/#openapi-spec-file-requirements","text":"The file provided should be a syntactically valid OpenAPI spec file. If it is not, an error will be raised at initialization time. For each path in the spec file, descriptions for 200 and 400 (in case parameter verification fails) status codes must be provided. If the path contains authentication requirements, a 401 status code description must also be provided. In addition, for each status code, at least one example must be provided. Note that, at present, only the application/json media type is supported.","title":"OpenAPI Spec File Requirements"},{"location":"http_server/#supported-authentication-methods","text":"Currently, the following Authentication methods/mechanisms are supported: API Key authentication (key may be present in the headers, query parameters or cookies) HTTP Authentication (Basic or Bearer authentication)","title":"Supported Authentication Methods"},{"location":"http_server/#providing-examples","text":"There are several ways to define response examples in an OpenAPI spec file. If there are multiple examples defined for a particular path status code, you can specify a particular response by using the X-Mock-Response-Example header with the name of the desired example. The mock server follows the following priority order when parsing the spec file for examples: If the X-Mock-Response-Example header is present, then the example corresponding to the value of that header is immediately fetched and returned. If no X-Mock-Response-Example header is present, it first tries to fetch an example from the schema key within the media type object. If no example is found here, it then attempts to fetch the example from the example key in the media type object. Next, it attempts to fetch the first value found in the examples key of the media type object. If still no example is found, it simply raises an exception. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \"content\" : { \"application/json\" : { \"schema\" : { \"example\" : \"This value is checked first\" }, \"example\" : \"This value is checked second\" , \"examples\" : { \"example1\" : { \"value\" : \"This value is checked third\" }, \"example2\" : { \"value\" : \"This value would be returned if the X-Mock-Response-Example header is passed with value 'example2'\" } } } }","title":"Providing Examples"},{"location":"http_server/#package-comhexagonkthttpserver","text":"This package defines the classes used in the HTTP DSL.","title":"Package com.hexagonkt.http.server"},{"location":"http_server/#package-comhexagonkthttpservercallbacks","text":"TODO","title":"Package com.hexagonkt.http.server.callbacks"},{"location":"http_server/#package-comhexagonkthttpserverhandlers","text":"TODO","title":"Package com.hexagonkt.http.server.handlers"},{"location":"http_server/#package-comhexagonkthttpservermodel","text":"TODO","title":"Package com.hexagonkt.http.server.model"},{"location":"http_server_jetty/","text":"Module http_server_jetty \u00b6 Jetty adapter for the http_server port. Install the Dependency \u00b6 build.gradle pom.xml 1 2 3 repositories { mavenCentral () } 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> http_server_jetty </artifactId> <version> $hexagonVersion </version> </dependency> Package com.hexagonkt.http.server.jetty \u00b6 Code implementing the Jetty HTTP server adapter.","title":"Module http_server_jetty"},{"location":"http_server_jetty/#module-http_server_jetty","text":"Jetty adapter for the http_server port.","title":"Module http_server_jetty"},{"location":"http_server_jetty/#install-the-dependency","text":"build.gradle pom.xml 1 2 3 repositories { mavenCentral () } 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> http_server_jetty </artifactId> <version> $hexagonVersion </version> </dependency>","title":"Install the Dependency"},{"location":"http_server_jetty/#package-comhexagonkthttpserverjetty","text":"Code implementing the Jetty HTTP server adapter.","title":"Package com.hexagonkt.http.server.jetty"},{"location":"http_server_servlet/","text":"Module http_server_servlet \u00b6 TODO Install the Dependency \u00b6 build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } implementation ( \"com.hexagonkt:http_server_servlet:$hexagonVersion\" ) 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> http_server_servlet </artifactId> <version> $hexagonVersion </version> </dependency> Package com.hexagonkt.http.server.servlet \u00b6 TODO","title":"Module http_server_servlet"},{"location":"http_server_servlet/#module-http_server_servlet","text":"TODO","title":"Module http_server_servlet"},{"location":"http_server_servlet/#install-the-dependency","text":"build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } implementation ( \"com.hexagonkt:http_server_servlet:$hexagonVersion\" ) 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> http_server_servlet </artifactId> <version> $hexagonVersion </version> </dependency>","title":"Install the Dependency"},{"location":"http_server_servlet/#package-comhexagonkthttpserverservlet","text":"TODO","title":"Package com.hexagonkt.http.server.servlet"},{"location":"logging_logback/","text":"Module logging_logback \u00b6 Contains the logger adapter for the Logback logging library. Install the Dependency \u00b6 build.gradle pom.xml 1 implementation ( \"com.hexagonkt:logging_logback:$hexagonVersion\" ) 1 2 3 4 5 6 7 8 9 <!-- ! Pick ONLY ONE of the options below !--> <!-- Full featured implementation --> <dependency> <groupId> com.hexagonkt </groupId> <artifactId> logging_logback </artifactId> <version> $hexagonVersion </version> </dependency> Info The above adapter bridge other logging libraries that may be used by other third party libraries you use (if you want to disable this behaviour, you need to explicitly exclude bridging libraries). build.gradle pom.xml 1 2 3 4 // Bridges runtimeOnly ( \"org.slf4j:jcl-over-slf4j:1.7.30\" ) runtimeOnly ( \"org.slf4j:log4j-over-slf4j:1.7.30\" ) runtimeOnly ( \"org.slf4j:jul-to-slf4j:1.7.30\" ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 <dependency> <groupId> org.slf4j </groupId> <artifactId> jcl-over-slf4j </artifactId> <version> 1.7.30 </version> </dependency> <dependency> <groupId> org.slf4j </groupId> <artifactId> log4j-over-slf4j </artifactId> <version> 1.7.30 </version> </dependency> <dependency> <groupId> org.slf4j </groupId> <artifactId> jul-to-slf4j </artifactId> <version> 1.7.30 </version> </dependency> Package com.hexagonkt.logging.logback \u00b6 Provides a logging management capabilities abstracting the application from logging libraries.","title":"Module logging_logback"},{"location":"logging_logback/#module-logging_logback","text":"Contains the logger adapter for the Logback logging library.","title":"Module logging_logback"},{"location":"logging_logback/#install-the-dependency","text":"build.gradle pom.xml 1 implementation ( \"com.hexagonkt:logging_logback:$hexagonVersion\" ) 1 2 3 4 5 6 7 8 9 <!-- ! Pick ONLY ONE of the options below !--> <!-- Full featured implementation --> <dependency> <groupId> com.hexagonkt </groupId> <artifactId> logging_logback </artifactId> <version> $hexagonVersion </version> </dependency> Info The above adapter bridge other logging libraries that may be used by other third party libraries you use (if you want to disable this behaviour, you need to explicitly exclude bridging libraries). build.gradle pom.xml 1 2 3 4 // Bridges runtimeOnly ( \"org.slf4j:jcl-over-slf4j:1.7.30\" ) runtimeOnly ( \"org.slf4j:log4j-over-slf4j:1.7.30\" ) runtimeOnly ( \"org.slf4j:jul-to-slf4j:1.7.30\" ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 <dependency> <groupId> org.slf4j </groupId> <artifactId> jcl-over-slf4j </artifactId> <version> 1.7.30 </version> </dependency> <dependency> <groupId> org.slf4j </groupId> <artifactId> log4j-over-slf4j </artifactId> <version> 1.7.30 </version> </dependency> <dependency> <groupId> org.slf4j </groupId> <artifactId> jul-to-slf4j </artifactId> <version> 1.7.30 </version> </dependency>","title":"Install the Dependency"},{"location":"logging_logback/#package-comhexagonktlogginglogback","text":"Provides a logging management capabilities abstracting the application from logging libraries.","title":"Package com.hexagonkt.logging.logback"},{"location":"logging_slf4j_jul/","text":"Module logging_slf4j_jul \u00b6 Contains the logger adapter for the SLF4J JUL logging library. Install the Dependency \u00b6 build.gradle pom.xml 1 implementation ( \"com.hexagonkt:logging_slf4j_jul:$hexagonVersion\" ) 1 2 3 4 5 6 7 8 9 <!-- ! Pick ONLY ONE of the options below !--> <!-- Full featured implementation --> <dependency> <groupId> com.hexagonkt </groupId> <artifactId> logging_slf4j_jul </artifactId> <version> $hexagonVersion </version> </dependency> Info The above adapter bridge other logging libraries that may be used by other third party libraries you use (if you want to disable this behaviour, you need to explicitly exclude bridging libraries). build.gradle pom.xml 1 2 3 // Bridges runtimeOnly ( \"org.slf4j:jcl-over-slf4j:1.7.30\" ) runtimeOnly ( \"org.slf4j:log4j-over-slf4j:1.7.30\" ) 1 2 3 4 5 6 7 8 9 10 <dependency> <groupId> org.slf4j </groupId> <artifactId> jcl-over-slf4j </artifactId> <version> 1.7.30 </version> </dependency> <dependency> <groupId> org.slf4j </groupId> <artifactId> log4j-over-slf4j </artifactId> <version> 1.7.30 </version> </dependency> Package com.hexagonkt.logging.slf4j.jul \u00b6 Provides a logging management capabilities abstracting the application from logging libraries.","title":"Module logging_slf4j_jul"},{"location":"logging_slf4j_jul/#module-logging_slf4j_jul","text":"Contains the logger adapter for the SLF4J JUL logging library.","title":"Module logging_slf4j_jul"},{"location":"logging_slf4j_jul/#install-the-dependency","text":"build.gradle pom.xml 1 implementation ( \"com.hexagonkt:logging_slf4j_jul:$hexagonVersion\" ) 1 2 3 4 5 6 7 8 9 <!-- ! Pick ONLY ONE of the options below !--> <!-- Full featured implementation --> <dependency> <groupId> com.hexagonkt </groupId> <artifactId> logging_slf4j_jul </artifactId> <version> $hexagonVersion </version> </dependency> Info The above adapter bridge other logging libraries that may be used by other third party libraries you use (if you want to disable this behaviour, you need to explicitly exclude bridging libraries). build.gradle pom.xml 1 2 3 // Bridges runtimeOnly ( \"org.slf4j:jcl-over-slf4j:1.7.30\" ) runtimeOnly ( \"org.slf4j:log4j-over-slf4j:1.7.30\" ) 1 2 3 4 5 6 7 8 9 10 <dependency> <groupId> org.slf4j </groupId> <artifactId> jcl-over-slf4j </artifactId> <version> 1.7.30 </version> </dependency> <dependency> <groupId> org.slf4j </groupId> <artifactId> log4j-over-slf4j </artifactId> <version> 1.7.30 </version> </dependency>","title":"Install the Dependency"},{"location":"logging_slf4j_jul/#package-comhexagonktloggingslf4jjul","text":"Provides a logging management capabilities abstracting the application from logging libraries.","title":"Package com.hexagonkt.logging.slf4j.jul"},{"location":"maven/","text":"Parent POMs \u00b6 If you want to use Maven to build your Kotlin applications, you can set up your POM to inherit from the Hexagon's parent POM. This POM configures Kotlin and Hexagon for you. There are two different flavors available (based on the directory schema you want to use): The standard layout POM The lean layout POM Standard Parent POM \u00b6 This layout is the well-known standard one, it has more directories but its widely used. Set up the Kotlin plugin Define Hexagon dependencies' versions Use JUnit 5 and MockK for testing Configure Jacoco coverage report 1 2 3 4 5 <parent> <groupId> com.hexagonkt </groupId> <artifactId> kotlin_pom </artifactId> <version> $hexagonVersion </version> </parent> Lean Parent POM \u00b6 This directory layout has less nested directories, and it is more compact. The main downside of using this approach is that it differs of the standard one. Inherits from the Standard Parent POM (it provides all its features) Change the source directories to be main and test instead src/{main,test}/kotlin Store resources together with source files instead of src/<sourceSet>/resources 1 2 3 4 5 <parent> <groupId> com.hexagonkt </groupId> <artifactId> kotlin_lean_pom </artifactId> <version> $hexagonVersion </version> </parent>","title":"Maven Parent POM"},{"location":"maven/#parent-poms","text":"If you want to use Maven to build your Kotlin applications, you can set up your POM to inherit from the Hexagon's parent POM. This POM configures Kotlin and Hexagon for you. There are two different flavors available (based on the directory schema you want to use): The standard layout POM The lean layout POM","title":"Parent POMs"},{"location":"maven/#standard-parent-pom","text":"This layout is the well-known standard one, it has more directories but its widely used. Set up the Kotlin plugin Define Hexagon dependencies' versions Use JUnit 5 and MockK for testing Configure Jacoco coverage report 1 2 3 4 5 <parent> <groupId> com.hexagonkt </groupId> <artifactId> kotlin_pom </artifactId> <version> $hexagonVersion </version> </parent>","title":"Standard Parent POM"},{"location":"maven/#lean-parent-pom","text":"This directory layout has less nested directories, and it is more compact. The main downside of using this approach is that it differs of the standard one. Inherits from the Standard Parent POM (it provides all its features) Change the source directories to be main and test instead src/{main,test}/kotlin Store resources together with source files instead of src/<sourceSet>/resources 1 2 3 4 5 <parent> <groupId> com.hexagonkt </groupId> <artifactId> kotlin_lean_pom </artifactId> <version> $hexagonVersion </version> </parent>","title":"Lean Parent POM"},{"location":"planning/","text":"You can check current tasks, priorities, and upcoming milestones on the following places: Organization board : main toolkit and organization tasks (i.e.: create example projects). Roadmap : upcoming releases status. Contains milestones' pending and completed tasks. If you miss some feature you would like to see implemented, you can request it using the enhancement GitHub template. If you want to help us decide which tasks to pick first, you may prioritize issues by adding the reaction on the issues more important to you.","title":"Planning"},{"location":"quick_start/","text":"In this guide, we are going to create a sample HTTP service. You can read the Core or HTTP Server modules documentation for more information. You can use both Gradle and Maven to build your application. You can start by cloning a starter project ( Gradle Starter or Maven Starter ). Or you can create a project from scratch following these steps: Configure Kotlin in Gradle or Maven . Add the dependency in Gradle or Maven: build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } implementation ( \"com.hexagonkt:http_server_jetty:$hexagonVersion\" ) 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> http_server_jetty </artifactId> <version> $hexagonVersion </version> </dependency> Write the code in the src/main/kotlin/Hello.kt file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import com.hexagonkt.http.server.jetty.serve lateinit var server : HttpServer /** * Start a Hello World server, serving at path \"/hello\". */ fun main () { server = serve { get ( \"/hello/{name}\" ) { val name = pathParameters [ \"name\" ] ok ( \"Hello $ name !\" , contentType = ContentType ( PLAIN )) } } } Run the service and view the results at: http://localhost:2010/hello Tip If you use Gradle, you can use the Application Helper and run the application watching for changes with the command: ./gradlew watch -t Dependencies Verification \u00b6 Hexagon's dependencies are signed, you can get the public key at the OpenPGP Public Key Server or here . These are the details of the public key: 1 2 pub 4096R/2AEE3721 2020-05-30 Hexagon Toolkit (Key used to sign published binaries) <project@hexagonkt.com> Fingerprint=792B D37F F598 91C4 AC6F 8D92 3B26 711D 2AEE 3721 Next Steps \u00b6 To continue learning about this toolkit, you can: Check the Developer Guide for more details. Clone the Gradle Starter or Maven Starter repository for a minimal fully working example (including tests). Proceed to the Examples section to check code snippets or full example projects.","title":"Quick Start"},{"location":"quick_start/#dependencies-verification","text":"Hexagon's dependencies are signed, you can get the public key at the OpenPGP Public Key Server or here . These are the details of the public key: 1 2 pub 4096R/2AEE3721 2020-05-30 Hexagon Toolkit (Key used to sign published binaries) <project@hexagonkt.com> Fingerprint=792B D37F F598 91C4 AC6F 8D92 3B26 711D 2AEE 3721","title":"Dependencies Verification"},{"location":"quick_start/#next-steps","text":"To continue learning about this toolkit, you can: Check the Developer Guide for more details. Clone the Gradle Starter or Maven Starter repository for a minimal fully working example (including tests). Proceed to the Examples section to check code snippets or full example projects.","title":"Next Steps"},{"location":"serialization/","text":"Module serialization \u00b6 This module holds serialization utilities. Install the Dependency \u00b6 This module is not meant to be imported directly. It will be included by using any other part of the toolkit. However, if you only want to use the utilities, logging or serialization (i.e., for a desktop application), you can import it with the following code: build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } implementation ( \"com.hexagonkt:serialization:$hexagonVersion\" ) 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> serialization </artifactId> <version> $hexagonVersion </version> </dependency> Defined Ports \u00b6 TODO Document module exposed ports: * Mapper * SerializationFormat Serialization \u00b6 The core module has utilities to serialize/parse data classes to JSON and YAML. Read the following snippet for details: 1 Package com.hexagonkt.serialization \u00b6 Parse/serialize data in different formats to class instances.","title":"Module serialization"},{"location":"serialization/#module-serialization","text":"This module holds serialization utilities.","title":"Module serialization"},{"location":"serialization/#install-the-dependency","text":"This module is not meant to be imported directly. It will be included by using any other part of the toolkit. However, if you only want to use the utilities, logging or serialization (i.e., for a desktop application), you can import it with the following code: build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } implementation ( \"com.hexagonkt:serialization:$hexagonVersion\" ) 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> serialization </artifactId> <version> $hexagonVersion </version> </dependency>","title":"Install the Dependency"},{"location":"serialization/#defined-ports","text":"TODO Document module exposed ports: * Mapper * SerializationFormat","title":"Defined Ports"},{"location":"serialization/#serialization","text":"The core module has utilities to serialize/parse data classes to JSON and YAML. Read the following snippet for details: 1","title":"Serialization"},{"location":"serialization/#package-comhexagonktserialization","text":"Parse/serialize data in different formats to class instances.","title":"Package com.hexagonkt.serialization"},{"location":"site/","text":"Project Site \u00b6 The site is generated using MkDocs and uses Google Analytics for usage statistics. The MkDocs theme used is MkDocs Material . Site generation requires Python pip installed. To generate the site you MUST BUILD THE PROJECT previously ( ./gradlew build ) in a separated command, after that you can use: ./gradlew buildSite which executes: mkdocs build -csq . To run the site inside a server for development, execute: ./gradlew serveSite . The site will be served at: http://localhost:8000 . You can also build the site and serve the build directory using: python -m SimpleHTTPServer . The site properties are loaded from mkdocs.yml file. The content from pages is copied to build/content in order to add the API Markdown to content. The site takes the Dokka API generated by all modules and add it to the site. Pages have a header with a button to edit the content in GitHub .","title":"Project Site"},{"location":"site/#project-site","text":"The site is generated using MkDocs and uses Google Analytics for usage statistics. The MkDocs theme used is MkDocs Material . Site generation requires Python pip installed. To generate the site you MUST BUILD THE PROJECT previously ( ./gradlew build ) in a separated command, after that you can use: ./gradlew buildSite which executes: mkdocs build -csq . To run the site inside a server for development, execute: ./gradlew serveSite . The site will be served at: http://localhost:8000 . You can also build the site and serve the build directory using: python -m SimpleHTTPServer . The site properties are loaded from mkdocs.yml file. The content from pages is copied to build/content in order to add the API Markdown to content. The site takes the Dokka API generated by all modules and add it to the site. Pages have a header with a button to edit the content in GitHub .","title":"Project Site"},{"location":"starters/","text":"Maven Starters \u00b6 This module holds the Maven parent POMs with Kotlin setup to ease the project creation using Maven . To use them declare the following parent section inside your pom.xml file: 1 2 3 4 5 <parent> <groupId> com.hexagonkt </groupId> <artifactId> kotlin_pom </artifactId> <version> $VERSION </version> </parent> Or: 1 2 3 4 5 <parent> <groupId> com.hexagonkt </groupId> <artifactId> kotlin_lean_pom </artifactId> <version> $VERSION </version> </parent>","title":"Starters"},{"location":"starters/#maven-starters","text":"This module holds the Maven parent POMs with Kotlin setup to ease the project creation using Maven . To use them declare the following parent section inside your pom.xml file: 1 2 3 4 5 <parent> <groupId> com.hexagonkt </groupId> <artifactId> kotlin_pom </artifactId> <version> $VERSION </version> </parent> Or: 1 2 3 4 5 <parent> <groupId> com.hexagonkt </groupId> <artifactId> kotlin_lean_pom </artifactId> <version> $VERSION </version> </parent>","title":"Maven Starters"},{"location":"templates/","text":"Module templates \u00b6 This port provides a common interface for rendering templates with multiple different template engines. Install the Dependency \u00b6 This module is not meant to be used directly. You should include any Adapter implementing this feature (as templates_pebble and/or templates_freemarker ) in order to process templates. You can use many adapters in the same application to be able to handle different template engines at the same time. Register a Template Engine \u00b6 You can register multiple template engines using regular expressions: 1 2 3 4 5 TemplateManager . adapters = mapOf ( Regex ( \".*\\\\.html\" ) to SampleTemplateAdapter ( \"html\" ), Regex ( \".*\\\\.txt\" ) to SampleTemplateAdapter ( \"text\" ), Regex ( \".*\" ) to SampleTemplateAdapter ( \"others\" ), ) The template adapter is selected from top to bottom, picking the first matched one. You can use Glob syntax to bind patterns to template adapters if you prefer: 1 2 3 4 5 TemplateManager . adapters = mapOf ( Glob ( \"*.html\" ). regex to SampleTemplateAdapter ( \"html\" ), Glob ( \"*.txt\" ). regex to SampleTemplateAdapter ( \"text\" ), Glob ( \"*\" ). regex to SampleTemplateAdapter ( \"others\" ), ) Usage \u00b6 To render a template, you have to use the TemplateManager object. The data to be used inside the template must be supplied in a map (context), the template URL and current time-stamp ( _template_ and _now_ variables) are added to the context automatically. Check the code below for an example: 1 2 val context = mapOf ( \"key1\" to \"value1\" , \"key2\" to \"value2\" ) val rendered = TemplateManager . render ( URL ( \"classpath:template.txt\" ), context ) Package com.hexagonkt.templates \u00b6 Feature implementation code.","title":"Templates"},{"location":"templates/#module-templates","text":"This port provides a common interface for rendering templates with multiple different template engines.","title":"Module templates"},{"location":"templates/#install-the-dependency","text":"This module is not meant to be used directly. You should include any Adapter implementing this feature (as templates_pebble and/or templates_freemarker ) in order to process templates. You can use many adapters in the same application to be able to handle different template engines at the same time.","title":"Install the Dependency"},{"location":"templates/#register-a-template-engine","text":"You can register multiple template engines using regular expressions: 1 2 3 4 5 TemplateManager . adapters = mapOf ( Regex ( \".*\\\\.html\" ) to SampleTemplateAdapter ( \"html\" ), Regex ( \".*\\\\.txt\" ) to SampleTemplateAdapter ( \"text\" ), Regex ( \".*\" ) to SampleTemplateAdapter ( \"others\" ), ) The template adapter is selected from top to bottom, picking the first matched one. You can use Glob syntax to bind patterns to template adapters if you prefer: 1 2 3 4 5 TemplateManager . adapters = mapOf ( Glob ( \"*.html\" ). regex to SampleTemplateAdapter ( \"html\" ), Glob ( \"*.txt\" ). regex to SampleTemplateAdapter ( \"text\" ), Glob ( \"*\" ). regex to SampleTemplateAdapter ( \"others\" ), )","title":"Register a Template Engine"},{"location":"templates/#usage","text":"To render a template, you have to use the TemplateManager object. The data to be used inside the template must be supplied in a map (context), the template URL and current time-stamp ( _template_ and _now_ variables) are added to the context automatically. Check the code below for an example: 1 2 val context = mapOf ( \"key1\" to \"value1\" , \"key2\" to \"value2\" ) val rendered = TemplateManager . render ( URL ( \"classpath:template.txt\" ), context )","title":"Usage"},{"location":"templates/#package-comhexagonkttemplates","text":"Feature implementation code.","title":"Package com.hexagonkt.templates"},{"location":"templates_freemarker/","text":"Module templates_freemarker \u00b6 This module provides an adapter for the templates Port supporting the Apache FreeMarker template engine. For usage instructions, refer to the Templates Port documentation . Install the Dependency \u00b6 build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } implementation ( \"com.hexagonkt:templates_freemarker:$hexagonVersion\" ) 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> templates_freemarker </artifactId> <version> $hexagonVersion </version> </dependency> Package com.hexagonkt.templates.freemarker \u00b6 Classes that implement the Templates Port interface with the FreeMarker engine.","title":"Module templates_freemarker"},{"location":"templates_freemarker/#module-templates_freemarker","text":"This module provides an adapter for the templates Port supporting the Apache FreeMarker template engine. For usage instructions, refer to the Templates Port documentation .","title":"Module templates_freemarker"},{"location":"templates_freemarker/#install-the-dependency","text":"build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } implementation ( \"com.hexagonkt:templates_freemarker:$hexagonVersion\" ) 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> templates_freemarker </artifactId> <version> $hexagonVersion </version> </dependency>","title":"Install the Dependency"},{"location":"templates_freemarker/#package-comhexagonkttemplatesfreemarker","text":"Classes that implement the Templates Port interface with the FreeMarker engine.","title":"Package com.hexagonkt.templates.freemarker"},{"location":"templates_pebble/","text":"Module templates_pebble \u00b6 Pebble template engine adapter for Hexagon. For usage instructions, refer to the Templates Port documentation . Install the Dependency \u00b6 build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } implementation ( \"com.hexagonkt:templates_pebble:$hexagonVersion\" ) 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> templates_pebble </artifactId> <version> $hexagonVersion </version> </dependency> Package com.hexagonkt.templates.pebble \u00b6 Classes that implement the Templates Port interface with the Pebble engine.","title":"Module templates_pebble"},{"location":"templates_pebble/#module-templates_pebble","text":"Pebble template engine adapter for Hexagon. For usage instructions, refer to the Templates Port documentation .","title":"Module templates_pebble"},{"location":"templates_pebble/#install-the-dependency","text":"build.gradle pom.xml 1 2 3 4 5 repositories { mavenCentral () } implementation ( \"com.hexagonkt:templates_pebble:$hexagonVersion\" ) 1 2 3 4 5 <dependency> <groupId> com.hexagonkt </groupId> <artifactId> templates_pebble </artifactId> <version> $hexagonVersion </version> </dependency>","title":"Install the Dependency"},{"location":"templates_pebble/#package-comhexagonkttemplatespebble","text":"Classes that implement the Templates Port interface with the Pebble engine.","title":"Package com.hexagonkt.templates.pebble"},{"location":"examples/example_projects/","text":"Todo-Backend \u00b6 Sample application for the Todo-Backend project which implements TodoMVC backends. You can check the code here \u2197 . Real World \u00b6 Hexagon RealWorld backend implementation. The source code is available here \u2197 . Contact Application \u00b6 Sample contact application that showcases the structure of a Hexagon service. Source code can be checked here \u2197 . Twitter Clone \u00b6 Mini Twitter clone application showcasing the use of template rendering, handling form data and integration with MongoDB. You can find the repository here \u2197 .","title":"Example Projects"},{"location":"examples/example_projects/#todo-backend","text":"Sample application for the Todo-Backend project which implements TodoMVC backends. You can check the code here \u2197 .","title":"Todo-Backend"},{"location":"examples/example_projects/#real-world","text":"Hexagon RealWorld backend implementation. The source code is available here \u2197 .","title":"Real World"},{"location":"examples/example_projects/#contact-application","text":"Sample contact application that showcases the structure of a Hexagon service. Source code can be checked here \u2197 .","title":"Contact Application"},{"location":"examples/example_projects/#twitter-clone","text":"Mini Twitter clone application showcasing the use of template rendering, handling form data and integration with MongoDB. You can find the repository here \u2197 .","title":"Twitter Clone"},{"location":"examples/http_client_examples/","text":"HTTP Client Creation Example \u00b6 This example shows how to create HTTP Client instances. Check the full test for more information. Without setting parameters \u00b6 1 2 HttpClient ( adapter ) HttpClient ( adapter , URL ( \"http://host:1234/base\" )) Using client settings \u00b6 1 2 3 4 5 6 7 8 9 // All client settings parameters are optionals and provide default values HttpClient ( adapter , HttpClientSettings ( baseUrl = URL ( \"http://host:1234/base\" ), contentType = ContentType ( JSON ), useCookies = true , headers = multiMapOf ( \"x-api-Key\" to \"cafebabe\" ), // Headers used in all requests insecure = false , // If true, the client doesn't check server certificates sslSettings = SslSettings () // Key stores settings (check TLS section for details) )) Send Requests Example \u00b6 This example shows send HTTP requests to a server. Here you can check the full test . Generic request \u00b6 1 2 3 4 5 6 7 8 9 10 val request = HttpClientRequest ( method = GET , path = \"/\" , body = mapOf ( \"body\" to \"payload\" ). serialize (), headers = multiMapOf ( \"x-header\" to \"value\" ), queryParameters = multiMapOf ( \"qp\" to \"qpValue\" ), contentType = ContentType ( JSON ) ) val response = client . send ( request ) Shortcut without body sending \u00b6 1 2 3 4 5 6 7 8 val responseGet = client . get ( \"/\" ) val responseHead = client . head ( \"/\" ) val responsePost = client . post ( \"/\" ) val responsePut = client . put ( \"/\" ) val responseDelete = client . delete ( \"/\" ) val responseTrace = client . trace ( \"/\" ) val responseOptions = client . options ( \"/\" ) val responsePatch = client . patch ( \"/\" ) Shortcut with payload sending \u00b6 1 2 3 4 5 6 7 8 9 10 val body = mapOf ( \"key\" to \"value\" ) val serializedBody = body . serialize () val responseGet = client . get ( \"/\" , body = serializedBody ) val responsePost = client . post ( \"/\" , serializedBody ) val responsePut = client . put ( \"/\" , serializedBody ) val responseDelete = client . delete ( \"/\" , serializedBody ) val responseTrace = client . trace ( \"/\" , serializedBody ) val responseOptions = client . options ( \"/\" , serializedBody ) val responsePatch = client . patch ( \"/\" , serializedBody ) Shortcut including body and content type \u00b6 1 2 3 4 5 6 7 8 9 10 val body = mapOf ( \"key\" to \"value\" ) val serializedBody = body . serialize ( YAML ) val responseGet = client . get ( \"/\" , body = serializedBody , contentType = ContentType ( YAML )) val responsePost = client . post ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responsePut = client . put ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responseDelete = client . delete ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responseTrace = client . trace ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responseOptions = client . options ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responsePatch = client . patch ( \"/\" , serializedBody , contentType = ContentType ( YAML )) Use Cookies Example \u00b6 Check the details at the full test . 1 2 3 4 5 6 7 8 9 10 11 12 val cookieName = \"sampleCookie\" val cookieValue = \"sampleCookieValue\" // Set the cookie in the client client . cookies = client . cookies + HttpCookie ( cookieName , cookieValue ) // Assert that it is received in the server and change its value afterwards client . post ( \"/assertHasCookie?cookieName= $ cookieName \" ) client . post ( \"/addCookie?cookieName= $ cookieName &cookieValue= ${ cookieValue } _changed\" ) // Verify that the client cookie is updated assertEquals ( cookieValue + \"_changed\" , client . cookiesMap () [ cookieName ]?. value ) Multipart Requests Example \u00b6 Refer to the full test for more details. Send form fields \u00b6 1 2 val parts = listOf ( HttpPart ( \"name\" , \"value\" )) val response = client . send ( HttpClientRequest ( POST , path = \"/multipart\" , parts = parts )) Send and attached file \u00b6 1 2 3 val stream = URL ( \"classpath:assets/index.html\" ). readBytes () val parts = listOf ( HttpPart ( \"file\" , stream , \"index.html\" )) val response = client . send ( HttpClientRequest ( POST , path = \"/file\" , parts = parts )) Mutual TLS Example \u00b6 This example shows how make requests using mutual TLS between the client and the server. You can check the full test for more details. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Key store files val identity = \"hexagonkt.p12\" val trust = \"trust.p12\" // Default passwords are file name reversed val keyStorePassword = identity . reversed () val trustStorePassword = trust . reversed () // Key stores can be set as URIs to classpath resources (the triple slash is needed) val keyStore = URL ( \"classpath:ssl/ $ identity \" ) val trustStore = URL ( \"classpath:ssl/ $ trust \" ) val sslSettings = SslSettings ( keyStore = keyStore , keyStorePassword = keyStorePassword , trustStore = trustStore , trustStorePassword = trustStorePassword , clientAuth = true // Requires a valid certificate from the client (mutual TLS) ) val serverSettings = HttpServerSettings ( bindPort = 0 , protocol = HTTPS , // You can also use HTTP2 sslSettings = sslSettings ) val server = HttpServer ( serverAdapter (), serverSettings ) { get ( \"/hello\" ) { // We can access the certificate used by the client from the request val subjectDn = request . certificate () ?. subjectX500Principal ?. name ?: \"\" val h = response . headers + ( \"cert\" to subjectDn ) ok ( \"Hello World!\" , headers = h ) } } server . start () // We'll use the same certificate for the client (in a real scenario it would be different) val clientSettings = HttpClientSettings ( sslSettings = sslSettings ) // Create an HTTP client and make an HTTPS request val contextPath = URL ( \"https://localhost: ${ server . runtimePort } \" ) val client = HttpClient ( clientAdapter (), contextPath , clientSettings ) client . start () client . get ( \"/hello\" ). apply { logger . debug { body } // Assure the certificate received (and returned) by the server is correct assert ( headers . require ( \"cert\" ). startsWith ( \"CN=hexagonkt.com\" )) assertEquals ( \"Hello World!\" , body ) }","title":"HTTP Client"},{"location":"examples/http_client_examples/#http-client-creation-example","text":"This example shows how to create HTTP Client instances. Check the full test for more information.","title":"HTTP Client Creation Example"},{"location":"examples/http_client_examples/#without-setting-parameters","text":"1 2 HttpClient ( adapter ) HttpClient ( adapter , URL ( \"http://host:1234/base\" ))","title":"Without setting parameters"},{"location":"examples/http_client_examples/#using-client-settings","text":"1 2 3 4 5 6 7 8 9 // All client settings parameters are optionals and provide default values HttpClient ( adapter , HttpClientSettings ( baseUrl = URL ( \"http://host:1234/base\" ), contentType = ContentType ( JSON ), useCookies = true , headers = multiMapOf ( \"x-api-Key\" to \"cafebabe\" ), // Headers used in all requests insecure = false , // If true, the client doesn't check server certificates sslSettings = SslSettings () // Key stores settings (check TLS section for details) ))","title":"Using client settings"},{"location":"examples/http_client_examples/#send-requests-example","text":"This example shows send HTTP requests to a server. Here you can check the full test .","title":"Send Requests Example"},{"location":"examples/http_client_examples/#generic-request","text":"1 2 3 4 5 6 7 8 9 10 val request = HttpClientRequest ( method = GET , path = \"/\" , body = mapOf ( \"body\" to \"payload\" ). serialize (), headers = multiMapOf ( \"x-header\" to \"value\" ), queryParameters = multiMapOf ( \"qp\" to \"qpValue\" ), contentType = ContentType ( JSON ) ) val response = client . send ( request )","title":"Generic request"},{"location":"examples/http_client_examples/#shortcut-without-body-sending","text":"1 2 3 4 5 6 7 8 val responseGet = client . get ( \"/\" ) val responseHead = client . head ( \"/\" ) val responsePost = client . post ( \"/\" ) val responsePut = client . put ( \"/\" ) val responseDelete = client . delete ( \"/\" ) val responseTrace = client . trace ( \"/\" ) val responseOptions = client . options ( \"/\" ) val responsePatch = client . patch ( \"/\" )","title":"Shortcut without body sending"},{"location":"examples/http_client_examples/#shortcut-with-payload-sending","text":"1 2 3 4 5 6 7 8 9 10 val body = mapOf ( \"key\" to \"value\" ) val serializedBody = body . serialize () val responseGet = client . get ( \"/\" , body = serializedBody ) val responsePost = client . post ( \"/\" , serializedBody ) val responsePut = client . put ( \"/\" , serializedBody ) val responseDelete = client . delete ( \"/\" , serializedBody ) val responseTrace = client . trace ( \"/\" , serializedBody ) val responseOptions = client . options ( \"/\" , serializedBody ) val responsePatch = client . patch ( \"/\" , serializedBody )","title":"Shortcut with payload sending"},{"location":"examples/http_client_examples/#shortcut-including-body-and-content-type","text":"1 2 3 4 5 6 7 8 9 10 val body = mapOf ( \"key\" to \"value\" ) val serializedBody = body . serialize ( YAML ) val responseGet = client . get ( \"/\" , body = serializedBody , contentType = ContentType ( YAML )) val responsePost = client . post ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responsePut = client . put ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responseDelete = client . delete ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responseTrace = client . trace ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responseOptions = client . options ( \"/\" , serializedBody , contentType = ContentType ( YAML )) val responsePatch = client . patch ( \"/\" , serializedBody , contentType = ContentType ( YAML ))","title":"Shortcut including body and content type"},{"location":"examples/http_client_examples/#use-cookies-example","text":"Check the details at the full test . 1 2 3 4 5 6 7 8 9 10 11 12 val cookieName = \"sampleCookie\" val cookieValue = \"sampleCookieValue\" // Set the cookie in the client client . cookies = client . cookies + HttpCookie ( cookieName , cookieValue ) // Assert that it is received in the server and change its value afterwards client . post ( \"/assertHasCookie?cookieName= $ cookieName \" ) client . post ( \"/addCookie?cookieName= $ cookieName &cookieValue= ${ cookieValue } _changed\" ) // Verify that the client cookie is updated assertEquals ( cookieValue + \"_changed\" , client . cookiesMap () [ cookieName ]?. value )","title":"Use Cookies Example"},{"location":"examples/http_client_examples/#multipart-requests-example","text":"Refer to the full test for more details.","title":"Multipart Requests Example"},{"location":"examples/http_client_examples/#send-form-fields","text":"1 2 val parts = listOf ( HttpPart ( \"name\" , \"value\" )) val response = client . send ( HttpClientRequest ( POST , path = \"/multipart\" , parts = parts ))","title":"Send form fields"},{"location":"examples/http_client_examples/#send-and-attached-file","text":"1 2 3 val stream = URL ( \"classpath:assets/index.html\" ). readBytes () val parts = listOf ( HttpPart ( \"file\" , stream , \"index.html\" )) val response = client . send ( HttpClientRequest ( POST , path = \"/file\" , parts = parts ))","title":"Send and attached file"},{"location":"examples/http_client_examples/#mutual-tls-example","text":"This example shows how make requests using mutual TLS between the client and the server. You can check the full test for more details. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Key store files val identity = \"hexagonkt.p12\" val trust = \"trust.p12\" // Default passwords are file name reversed val keyStorePassword = identity . reversed () val trustStorePassword = trust . reversed () // Key stores can be set as URIs to classpath resources (the triple slash is needed) val keyStore = URL ( \"classpath:ssl/ $ identity \" ) val trustStore = URL ( \"classpath:ssl/ $ trust \" ) val sslSettings = SslSettings ( keyStore = keyStore , keyStorePassword = keyStorePassword , trustStore = trustStore , trustStorePassword = trustStorePassword , clientAuth = true // Requires a valid certificate from the client (mutual TLS) ) val serverSettings = HttpServerSettings ( bindPort = 0 , protocol = HTTPS , // You can also use HTTP2 sslSettings = sslSettings ) val server = HttpServer ( serverAdapter (), serverSettings ) { get ( \"/hello\" ) { // We can access the certificate used by the client from the request val subjectDn = request . certificate () ?. subjectX500Principal ?. name ?: \"\" val h = response . headers + ( \"cert\" to subjectDn ) ok ( \"Hello World!\" , headers = h ) } } server . start () // We'll use the same certificate for the client (in a real scenario it would be different) val clientSettings = HttpClientSettings ( sslSettings = sslSettings ) // Create an HTTP client and make an HTTPS request val contextPath = URL ( \"https://localhost: ${ server . runtimePort } \" ) val client = HttpClient ( clientAdapter (), contextPath , clientSettings ) client . start () client . get ( \"/hello\" ). apply { logger . debug { body } // Assure the certificate received (and returned) by the server is correct assert ( headers . require ( \"cert\" ). startsWith ( \"CN=hexagonkt.com\" )) assertEquals ( \"Hello World!\" , body ) }","title":"Mutual TLS Example"},{"location":"examples/http_server_examples/","text":"Books Example \u00b6 A simple CRUD example showing how to manage book resources. Here you can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 data class Book ( val author : String , val title : String ) private val books : MutableMap < Int , Book > = linkedMapOf ( 100 to Book ( \"Miguel de Cervantes\" , \"Don Quixote\" ), 101 to Book ( \"William Shakespeare\" , \"Hamlet\" ), 102 to Book ( \"Homer\" , \"The Odyssey\" ) ) private val path : PathHandler = path { post ( \"/books\" ) { val author = queryParameters [ \"author\" ] ?: return @post badRequest ( \"Missing author\" ) val title = queryParameters [ \"title\" ] ?: return @post badRequest ( \"Missing title\" ) val id = ( books . keys . maxOrNull () ?: 0 ) + 1 books += id to Book ( author , title ) created ( id . toString ()) } get ( \"/books/{id}\" ) { val bookId = pathParameters . require ( \"id\" ). toInt () val book = books [ bookId ] if ( book != null ) ok ( \"Title: ${ book . title } , Author: ${ book . author } \" ) else notFound ( \"Book not found\" ) } put ( \"/books/{id}\" ) { val bookId = pathParameters . require ( \"id\" ). toInt () val book = books [ bookId ] if ( book != null ) { books += bookId to book . copy ( author = queryParameters [ \"author\" ] ?: book . author , title = queryParameters [ \"title\" ] ?: book . title ) ok ( \"Book with id ' $ bookId ' updated\" ) } else { notFound ( \"Book not found\" ) } } delete ( \"/books/{id}\" ) { val bookId = pathParameters . require ( \"id\" ). toInt () val book = books [ bookId ] books -= bookId if ( book != null ) ok ( \"Book with id ' $ bookId ' deleted\" ) else notFound ( \"Book not found\" ) } // Matches path's requests with *any* HTTP method as a fallback (return 404 instead 405) after ( ALL - DELETE - PUT - GET , \"/books/{id}\" , status = NOT_FOUND ) { send ( METHOD_NOT_ALLOWED ) } get ( \"/books\" ) { ok ( books . keys . joinToString ( \" \" , transform = Int :: toString )) } } Session Example \u00b6 Example showing how to use sessions. Here you can check the full test . TODO Add example Cookies Example \u00b6 Demo server to show the use of cookies. Here you can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private val path : PathHandler = path { post ( \"/assertNoCookies\" ) { if ( request . cookies . isNotEmpty ()) internalServerError () else ok () } post ( \"/addCookie\" ) { val name = queryParameters . require ( \"cookieName\" ) val value = queryParameters . require ( \"cookieValue\" ) ok ( cookies = response . cookies + HttpCookie ( name , value )) } post ( \"/assertHasCookie\" ) { val cookieName = queryParameters . require ( \"cookieName\" ) val cookieValue = request . cookiesMap () [ cookieName ]?. value if ( queryParameters [ \"cookieValue\" ] != cookieValue ) internalServerError () else ok () } post ( \"/removeCookie\" ) { val cookie = request . cookiesMap (). require ( queryParameters . require ( \"cookieName\" )) ok ( cookies = response . cookies + cookie . delete ()) } } Error Handling Example \u00b6 Code to show how to handle callback exceptions and HTTP error codes. Here you can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class CustomException : IllegalArgumentException () private val path : PathHandler = path { /* * Catching `Exception` handles any unhandled exception, has to be the last executed (first * declared) */ exception < Exception > ( NOT_FOUND ) { internalServerError ( \"Root handler\" ) } exception < IllegalArgumentException > { val error = exception ?. message ?: exception ?. javaClass ?. name ?: fail val newHeaders = response . headers + ( \"runtime-error\" to error ) send ( HttpStatus ( 598 ), \"Runtime\" , headers = newHeaders ) } exception < UnsupportedOperationException > { val error = exception ?. message ?: exception ?. javaClass ?. name ?: fail val newHeaders = response . headers + ( \"error\" to error ) send ( HttpStatus ( 599 ), \"Unsupported\" , headers = newHeaders ) } get ( \"/exception\" ) { throw UnsupportedOperationException ( \"error message\" ) } get ( \"/baseException\" ) { throw CustomException () } get ( \"/unhandledException\" ) { error ( \"error message\" ) } get ( \"/invalidBody\" ) { ok ( LocalDateTime . now ()) } get ( \"/halt\" ) { internalServerError ( \"halted\" ) } get ( \"/588\" ) { send ( HttpStatus ( 588 )) } // It is possible to execute a handler upon a given status code before returning on ( pattern = \"*\" , status = HttpStatus ( 588 )) { send ( HttpStatus ( 578 ), \"588 -> 578\" ) } } Filters Example \u00b6 This example shows how to add filters before and after route execution. Here you can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 private val users : Map < String , String > = mapOf ( \"Turing\" to \"London\" , \"Dijkstra\" to \"Rotterdam\" ) private val path : PathHandler = path { filter ( \"*\" ) { val start = System . nanoTime () // Call next and store result to chain it val next = next () val time = ( System . nanoTime () - start ). toString () // Copies result from chain with the extra data next . send ( headers = response . headers + ( \"time\" to time )) } filter ( \"/protected/*\" ) { val authorization = request . headers [ \"authorization\" ] ?: return @filter send ( UNAUTHORIZED , \"Unauthorized\" ) val credentials = authorization . removePrefix ( \"Basic \" ) val userPassword = String ( credentials . decodeBase64 ()). split ( \":\" ) // Parameters set in call attributes are accessible in other filters and routes send ( attributes = attributes + ( \"username\" to userPassword [ 0 ] ) + ( \"password\" to userPassword [ 1 ] ) ). next () } // All matching filters are run in order unless call is halted filter ( \"/protected/*\" ) { if ( users [ attributes [ \"username\" ]] != attributes [ \"password\" ] ) send ( FORBIDDEN , \"Forbidden\" ) else next () } get ( \"/protected/hi\" ) { ok ( \"Hello ${ attributes [ \" username \" ] } !\" ) } path ( \"/after\" ) { after ( PUT ) { success ( ALREADY_REPORTED ) } after ( PUT , \"/second\" ) { success ( NO_CONTENT ) } after ( \"/second\" ) { success ( CREATED ) } after { success ( ACCEPTED ) } } } Files Example \u00b6 The following code shows how to serve resources and receive files. Here you can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 private val path : PathHandler = path { // Serve `public` resources folder on `/*` after ( methods = setOf ( GET ), pattern = \"/*\" , status = NOT_FOUND , callback = UrlCallback ( URL ( \"classpath:public\" )) ) path ( \"/static\" ) { get ( \"/files/*\" , UrlCallback ( URL ( \"classpath:assets\" ))) get ( \"/resources/*\" , FileCallback ( File ( directory ))) } get ( \"/html/*\" , UrlCallback ( URL ( \"classpath:assets\" ))) // Serve `assets` files on `/html/*` get ( \"/pub/*\" , FileCallback ( File ( directory ))) // Serve `test` folder on `/pub/*` post ( \"/multipart\" ) { val headers : MultiMap < String , String > = parts . first (). let { p -> val name = p . name val bodyString = p . bodyString () val size = p . size . toString () val fullType = p . contentType ?. mediaType ?. fullType ?: \"\" val contentDisposition = p . headers . require ( \"content-disposition\" ) multiMapOf ( \"name\" to name , \"body\" to bodyString , \"size\" to size , \"type\" to fullType , \"content-disposition\" to contentDisposition ) } ok ( headers = headers ) } post ( \"/file\" ) { val part = parts . first () val content = part . bodyString () ok ( content ) } post ( \"/form\" ) { fun serializeMap ( map : Map < String , List < String >> ): List < String > = listOf ( map . map { \" ${ it . key } : ${ it . value . joinToString ( \" , \" ) } }\" }. joinToString ( \"\\n\" ) ) val queryParams = serializeMap ( queryParameters . allValues ) val formParams = serializeMap ( formParameters . allValues ) val headers = multiMapOfLists ( \"query-params\" to queryParams , \"form-params\" to formParams ) ok ( headers = response . headers + headers ) } } CORS Example \u00b6 This example shows how to set up CORS for REST APIs used from the browser. Here you can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 val path : PathHandler = path { corsPath ( \"/default\" , CorsCallback ()) corsPath ( \"/example/org\" , CorsCallback ( \"example.org\" )) corsPath ( \"/no/credentials\" , CorsCallback ( supportCredentials = false )) corsPath ( \"/only/post\" , CorsCallback ( allowedMethods = setOf ( POST ))) corsPath ( \"/cache\" , CorsCallback ( preFlightMaxAge = 10 )) corsPath ( \"/exposed/headers\" , CorsCallback ( exposedHeaders = setOf ( \"head\" ))) corsPath ( \"/allowed/headers\" , CorsCallback ( allowedHeaders = setOf ( \"head\" ))) } private fun ServerBuilder . corsPath ( path : String , cors : CorsCallback ) { path ( path ) { // CORS settings can change for different routes filter ( pattern = \"*\" , callback = cors ) get ( \"/path\" ) { ok ( method . toString ()) } post ( \"/path\" ) { ok ( method . toString ()) } put ( \"/path\" ) { ok ( method . toString ()) } delete ( \"/path\" ) { ok ( method . toString ()) } get { ok ( method . toString ()) } post { ok ( method . toString ()) } put { ok ( method . toString ()) } delete { ok ( method . toString ()) } } } HTTPS Example \u00b6 The snippet below shows how to set up your server to use HTTPS and HTTP/2. You can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Key store files val identity = \"hexagonkt.p12\" val trust = \"trust.p12\" // Default passwords are file name reversed val keyStorePassword = identity . reversed () val trustStorePassword = trust . reversed () // Key stores can be set as URIs to classpath resources (the triple slash is needed) val keyStore = URL ( \"classpath:ssl/ $ identity \" ) val trustStore = URL ( \"classpath:ssl/ $ trust \" ) val sslSettings = SslSettings ( keyStore = keyStore , keyStorePassword = keyStorePassword , trustStore = trustStore , trustStorePassword = trustStorePassword , clientAuth = true // Requires a valid certificate from the client (mutual TLS) ) val serverSettings = HttpServerSettings ( bindPort = 0 , protocol = HTTPS , // You can also use HTTP2 sslSettings = sslSettings ) val server = HttpServer ( serverAdapter (), serverSettings ) { get ( \"/hello\" ) { // We can access the certificate used by the client from the request val subjectDn = request . certificate () ?. subjectX500Principal ?. name ?: \"\" val h = response . headers + ( \"cert\" to subjectDn ) ok ( \"Hello World!\" , headers = h ) } } server . start () // We'll use the same certificate for the client (in a real scenario it would be different) val clientSettings = HttpClientSettings ( sslSettings = sslSettings ) // Create an HTTP client and make an HTTPS request val contextPath = URL ( \"https://localhost: ${ server . runtimePort } \" ) val client = HttpClient ( clientAdapter (), contextPath , clientSettings ) client . start () client . get ( \"/hello\" ). apply { logger . debug { body } // Assure the certificate received (and returned) by the server is correct assert ( headers . require ( \"cert\" ). startsWith ( \"CN=hexagonkt.com\" )) assertEquals ( \"Hello World!\" , body ) }","title":"HTTP Server"},{"location":"examples/http_server_examples/#books-example","text":"A simple CRUD example showing how to manage book resources. Here you can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 data class Book ( val author : String , val title : String ) private val books : MutableMap < Int , Book > = linkedMapOf ( 100 to Book ( \"Miguel de Cervantes\" , \"Don Quixote\" ), 101 to Book ( \"William Shakespeare\" , \"Hamlet\" ), 102 to Book ( \"Homer\" , \"The Odyssey\" ) ) private val path : PathHandler = path { post ( \"/books\" ) { val author = queryParameters [ \"author\" ] ?: return @post badRequest ( \"Missing author\" ) val title = queryParameters [ \"title\" ] ?: return @post badRequest ( \"Missing title\" ) val id = ( books . keys . maxOrNull () ?: 0 ) + 1 books += id to Book ( author , title ) created ( id . toString ()) } get ( \"/books/{id}\" ) { val bookId = pathParameters . require ( \"id\" ). toInt () val book = books [ bookId ] if ( book != null ) ok ( \"Title: ${ book . title } , Author: ${ book . author } \" ) else notFound ( \"Book not found\" ) } put ( \"/books/{id}\" ) { val bookId = pathParameters . require ( \"id\" ). toInt () val book = books [ bookId ] if ( book != null ) { books += bookId to book . copy ( author = queryParameters [ \"author\" ] ?: book . author , title = queryParameters [ \"title\" ] ?: book . title ) ok ( \"Book with id ' $ bookId ' updated\" ) } else { notFound ( \"Book not found\" ) } } delete ( \"/books/{id}\" ) { val bookId = pathParameters . require ( \"id\" ). toInt () val book = books [ bookId ] books -= bookId if ( book != null ) ok ( \"Book with id ' $ bookId ' deleted\" ) else notFound ( \"Book not found\" ) } // Matches path's requests with *any* HTTP method as a fallback (return 404 instead 405) after ( ALL - DELETE - PUT - GET , \"/books/{id}\" , status = NOT_FOUND ) { send ( METHOD_NOT_ALLOWED ) } get ( \"/books\" ) { ok ( books . keys . joinToString ( \" \" , transform = Int :: toString )) } }","title":"Books Example"},{"location":"examples/http_server_examples/#session-example","text":"Example showing how to use sessions. Here you can check the full test . TODO Add example","title":"Session Example"},{"location":"examples/http_server_examples/#cookies-example","text":"Demo server to show the use of cookies. Here you can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private val path : PathHandler = path { post ( \"/assertNoCookies\" ) { if ( request . cookies . isNotEmpty ()) internalServerError () else ok () } post ( \"/addCookie\" ) { val name = queryParameters . require ( \"cookieName\" ) val value = queryParameters . require ( \"cookieValue\" ) ok ( cookies = response . cookies + HttpCookie ( name , value )) } post ( \"/assertHasCookie\" ) { val cookieName = queryParameters . require ( \"cookieName\" ) val cookieValue = request . cookiesMap () [ cookieName ]?. value if ( queryParameters [ \"cookieValue\" ] != cookieValue ) internalServerError () else ok () } post ( \"/removeCookie\" ) { val cookie = request . cookiesMap (). require ( queryParameters . require ( \"cookieName\" )) ok ( cookies = response . cookies + cookie . delete ()) } }","title":"Cookies Example"},{"location":"examples/http_server_examples/#error-handling-example","text":"Code to show how to handle callback exceptions and HTTP error codes. Here you can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class CustomException : IllegalArgumentException () private val path : PathHandler = path { /* * Catching `Exception` handles any unhandled exception, has to be the last executed (first * declared) */ exception < Exception > ( NOT_FOUND ) { internalServerError ( \"Root handler\" ) } exception < IllegalArgumentException > { val error = exception ?. message ?: exception ?. javaClass ?. name ?: fail val newHeaders = response . headers + ( \"runtime-error\" to error ) send ( HttpStatus ( 598 ), \"Runtime\" , headers = newHeaders ) } exception < UnsupportedOperationException > { val error = exception ?. message ?: exception ?. javaClass ?. name ?: fail val newHeaders = response . headers + ( \"error\" to error ) send ( HttpStatus ( 599 ), \"Unsupported\" , headers = newHeaders ) } get ( \"/exception\" ) { throw UnsupportedOperationException ( \"error message\" ) } get ( \"/baseException\" ) { throw CustomException () } get ( \"/unhandledException\" ) { error ( \"error message\" ) } get ( \"/invalidBody\" ) { ok ( LocalDateTime . now ()) } get ( \"/halt\" ) { internalServerError ( \"halted\" ) } get ( \"/588\" ) { send ( HttpStatus ( 588 )) } // It is possible to execute a handler upon a given status code before returning on ( pattern = \"*\" , status = HttpStatus ( 588 )) { send ( HttpStatus ( 578 ), \"588 -> 578\" ) } }","title":"Error Handling Example"},{"location":"examples/http_server_examples/#filters-example","text":"This example shows how to add filters before and after route execution. Here you can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 private val users : Map < String , String > = mapOf ( \"Turing\" to \"London\" , \"Dijkstra\" to \"Rotterdam\" ) private val path : PathHandler = path { filter ( \"*\" ) { val start = System . nanoTime () // Call next and store result to chain it val next = next () val time = ( System . nanoTime () - start ). toString () // Copies result from chain with the extra data next . send ( headers = response . headers + ( \"time\" to time )) } filter ( \"/protected/*\" ) { val authorization = request . headers [ \"authorization\" ] ?: return @filter send ( UNAUTHORIZED , \"Unauthorized\" ) val credentials = authorization . removePrefix ( \"Basic \" ) val userPassword = String ( credentials . decodeBase64 ()). split ( \":\" ) // Parameters set in call attributes are accessible in other filters and routes send ( attributes = attributes + ( \"username\" to userPassword [ 0 ] ) + ( \"password\" to userPassword [ 1 ] ) ). next () } // All matching filters are run in order unless call is halted filter ( \"/protected/*\" ) { if ( users [ attributes [ \"username\" ]] != attributes [ \"password\" ] ) send ( FORBIDDEN , \"Forbidden\" ) else next () } get ( \"/protected/hi\" ) { ok ( \"Hello ${ attributes [ \" username \" ] } !\" ) } path ( \"/after\" ) { after ( PUT ) { success ( ALREADY_REPORTED ) } after ( PUT , \"/second\" ) { success ( NO_CONTENT ) } after ( \"/second\" ) { success ( CREATED ) } after { success ( ACCEPTED ) } } }","title":"Filters Example"},{"location":"examples/http_server_examples/#files-example","text":"The following code shows how to serve resources and receive files. Here you can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 private val path : PathHandler = path { // Serve `public` resources folder on `/*` after ( methods = setOf ( GET ), pattern = \"/*\" , status = NOT_FOUND , callback = UrlCallback ( URL ( \"classpath:public\" )) ) path ( \"/static\" ) { get ( \"/files/*\" , UrlCallback ( URL ( \"classpath:assets\" ))) get ( \"/resources/*\" , FileCallback ( File ( directory ))) } get ( \"/html/*\" , UrlCallback ( URL ( \"classpath:assets\" ))) // Serve `assets` files on `/html/*` get ( \"/pub/*\" , FileCallback ( File ( directory ))) // Serve `test` folder on `/pub/*` post ( \"/multipart\" ) { val headers : MultiMap < String , String > = parts . first (). let { p -> val name = p . name val bodyString = p . bodyString () val size = p . size . toString () val fullType = p . contentType ?. mediaType ?. fullType ?: \"\" val contentDisposition = p . headers . require ( \"content-disposition\" ) multiMapOf ( \"name\" to name , \"body\" to bodyString , \"size\" to size , \"type\" to fullType , \"content-disposition\" to contentDisposition ) } ok ( headers = headers ) } post ( \"/file\" ) { val part = parts . first () val content = part . bodyString () ok ( content ) } post ( \"/form\" ) { fun serializeMap ( map : Map < String , List < String >> ): List < String > = listOf ( map . map { \" ${ it . key } : ${ it . value . joinToString ( \" , \" ) } }\" }. joinToString ( \"\\n\" ) ) val queryParams = serializeMap ( queryParameters . allValues ) val formParams = serializeMap ( formParameters . allValues ) val headers = multiMapOfLists ( \"query-params\" to queryParams , \"form-params\" to formParams ) ok ( headers = response . headers + headers ) } }","title":"Files Example"},{"location":"examples/http_server_examples/#cors-example","text":"This example shows how to set up CORS for REST APIs used from the browser. Here you can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 val path : PathHandler = path { corsPath ( \"/default\" , CorsCallback ()) corsPath ( \"/example/org\" , CorsCallback ( \"example.org\" )) corsPath ( \"/no/credentials\" , CorsCallback ( supportCredentials = false )) corsPath ( \"/only/post\" , CorsCallback ( allowedMethods = setOf ( POST ))) corsPath ( \"/cache\" , CorsCallback ( preFlightMaxAge = 10 )) corsPath ( \"/exposed/headers\" , CorsCallback ( exposedHeaders = setOf ( \"head\" ))) corsPath ( \"/allowed/headers\" , CorsCallback ( allowedHeaders = setOf ( \"head\" ))) } private fun ServerBuilder . corsPath ( path : String , cors : CorsCallback ) { path ( path ) { // CORS settings can change for different routes filter ( pattern = \"*\" , callback = cors ) get ( \"/path\" ) { ok ( method . toString ()) } post ( \"/path\" ) { ok ( method . toString ()) } put ( \"/path\" ) { ok ( method . toString ()) } delete ( \"/path\" ) { ok ( method . toString ()) } get { ok ( method . toString ()) } post { ok ( method . toString ()) } put { ok ( method . toString ()) } delete { ok ( method . toString ()) } } }","title":"CORS Example"},{"location":"examples/http_server_examples/#https-example","text":"The snippet below shows how to set up your server to use HTTPS and HTTP/2. You can check the full test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Key store files val identity = \"hexagonkt.p12\" val trust = \"trust.p12\" // Default passwords are file name reversed val keyStorePassword = identity . reversed () val trustStorePassword = trust . reversed () // Key stores can be set as URIs to classpath resources (the triple slash is needed) val keyStore = URL ( \"classpath:ssl/ $ identity \" ) val trustStore = URL ( \"classpath:ssl/ $ trust \" ) val sslSettings = SslSettings ( keyStore = keyStore , keyStorePassword = keyStorePassword , trustStore = trustStore , trustStorePassword = trustStorePassword , clientAuth = true // Requires a valid certificate from the client (mutual TLS) ) val serverSettings = HttpServerSettings ( bindPort = 0 , protocol = HTTPS , // You can also use HTTP2 sslSettings = sslSettings ) val server = HttpServer ( serverAdapter (), serverSettings ) { get ( \"/hello\" ) { // We can access the certificate used by the client from the request val subjectDn = request . certificate () ?. subjectX500Principal ?. name ?: \"\" val h = response . headers + ( \"cert\" to subjectDn ) ok ( \"Hello World!\" , headers = h ) } } server . start () // We'll use the same certificate for the client (in a real scenario it would be different) val clientSettings = HttpClientSettings ( sslSettings = sslSettings ) // Create an HTTP client and make an HTTPS request val contextPath = URL ( \"https://localhost: ${ server . runtimePort } \" ) val client = HttpClient ( clientAdapter (), contextPath , clientSettings ) client . start () client . get ( \"/hello\" ). apply { logger . debug { body } // Assure the certificate received (and returned) by the server is correct assert ( headers . require ( \"cert\" ). startsWith ( \"CN=hexagonkt.com\" )) assertEquals ( \"Hello World!\" , body ) }","title":"HTTPS Example"},{"location":"examples/templates_examples/","text":"Register Template Adapters \u00b6 Example to show how to register template adapters. full test . Using regular Expressions \u00b6 1 2 3 4 5 TemplateManager . adapters = mapOf ( Regex ( \".*\\\\.html\" ) to SampleTemplateAdapter ( \"html\" ), Regex ( \".*\\\\.txt\" ) to SampleTemplateAdapter ( \"text\" ), Regex ( \".*\" ) to SampleTemplateAdapter ( \"others\" ), ) Using globs \u00b6 1 2 3 4 5 TemplateManager . adapters = mapOf ( Glob ( \"*.html\" ). regex to SampleTemplateAdapter ( \"html\" ), Glob ( \"*.txt\" ). regex to SampleTemplateAdapter ( \"text\" ), Glob ( \"*\" ). regex to SampleTemplateAdapter ( \"others\" ), ) Process Templates \u00b6 Simple example to show how to process templates. full test . 1 2 val context = mapOf ( \"key1\" to \"value1\" , \"key2\" to \"value2\" ) val rendered = TemplateManager . render ( URL ( \"classpath:template.txt\" ), context )","title":"Templates"},{"location":"examples/templates_examples/#register-template-adapters","text":"Example to show how to register template adapters. full test .","title":"Register Template Adapters"},{"location":"examples/templates_examples/#using-regular-expressions","text":"1 2 3 4 5 TemplateManager . adapters = mapOf ( Regex ( \".*\\\\.html\" ) to SampleTemplateAdapter ( \"html\" ), Regex ( \".*\\\\.txt\" ) to SampleTemplateAdapter ( \"text\" ), Regex ( \".*\" ) to SampleTemplateAdapter ( \"others\" ), )","title":"Using regular Expressions"},{"location":"examples/templates_examples/#using-globs","text":"1 2 3 4 5 TemplateManager . adapters = mapOf ( Glob ( \"*.html\" ). regex to SampleTemplateAdapter ( \"html\" ), Glob ( \"*.txt\" ). regex to SampleTemplateAdapter ( \"text\" ), Glob ( \"*\" ). regex to SampleTemplateAdapter ( \"others\" ), )","title":"Using globs"},{"location":"examples/templates_examples/#process-templates","text":"Simple example to show how to process templates. full test . 1 2 val context = mapOf ( \"key1\" to \"value1\" , \"key2\" to \"value2\" ) val rendered = TemplateManager . render ( URL ( \"classpath:template.txt\" ), context )","title":"Process Templates"},{"location":"guides/mtls/","text":"mTLS in Hexagon \u00b6 Generate sample certificates Server \u00b6 Creating the service Forcing client authentication Checking client identity Client \u00b6 Trusting server certificate Setting client certificate","title":"Mtls"},{"location":"guides/mtls/#mtls-in-hexagon","text":"Generate sample certificates","title":"mTLS in Hexagon"},{"location":"guides/mtls/#server","text":"Creating the service Forcing client authentication Checking client identity","title":"Server"},{"location":"guides/mtls/#client","text":"Trusting server certificate Setting client certificate","title":"Client"}]}