<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Path.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">site</a> &gt; <a href="index.source.html" class="el_package">com.hexagonkt.http</a> &gt; <span class="el_source">Path.kt</span></div><h1>Path.kt</h1><pre class="source lang-java linenums">package com.hexagonkt.http

import com.hexagonkt.core.helpers.findGroups

/**
 * A path definition. It parses path patterns and extract values for parameters.
 *
 * Differences with Sinatra:
 *
 *   * No splats (you can use named parameters though)
 *   * Delimiter is {var} to conform with [RFC 6570](https://tools.ietf.org/html/rfc6570)
 */
<span class="fc" id="L13">data class Path(val pattern: String) {</span>
    private companion object {
        const val PARAMETER_PREFIX = &quot;{&quot;
        const val PARAMETER_SUFFIX = &quot;}&quot;

        const val WILDCARD = &quot;*&quot;

<span class="fc" id="L20">        val WILDCARD_REGEX = Regex(&quot;\\$WILDCARD&quot;)</span>
<span class="fc" id="L21">        val PARAMETER_REGEX = Regex(&quot;\\$PARAMETER_PREFIX\\w+$PARAMETER_SUFFIX&quot;)</span>
<span class="fc" id="L22">        val PLACEHOLDER_REGEX = Regex(&quot;\\$WILDCARD|\\$PARAMETER_PREFIX\\w+$PARAMETER_SUFFIX&quot;)</span>
    }

<span class="fc" id="L25">    init {</span>
<span class="fc bfc" id="L26" title="All 4 branches covered.">        val validPrefix = pattern.startsWith(&quot;/&quot;) || pattern.startsWith(&quot;*&quot;)</span>
<span class="fc bfc" id="L27" title="All 2 branches covered.">        require(validPrefix) { &quot;'$pattern' must start with '/' or '*'&quot; }</span>
<span class="fc bfc" id="L28" title="All 2 branches covered.">        val validVariables = !pattern.contains(&quot;:&quot;)</span>
<span class="fc bfc" id="L29" title="All 2 branches covered.">        require(validVariables) { &quot;Variables have {var} format. Path cannot have ':' $pattern&quot; }</span>
<span class="fc" id="L30">    }</span>

<span class="fc" id="L32">    val hasWildcards by lazy { WILDCARD_REGEX in pattern }</span>
<span class="fc" id="L33">    val hasParameters by lazy { PARAMETER_REGEX in pattern }</span>

<span class="fc" id="L35">    val parameterIndex: List&lt;String&gt; by lazy {</span>
<span class="fc bfc" id="L36" title="All 2 branches covered.">        if (hasParameters)</span>
<span class="fc" id="L37">            PLACEHOLDER_REGEX.findAll(pattern)</span>
<span class="fc" id="L38">                .map {</span>
<span class="fc bfc" id="L39" title="All 2 branches covered.">                    if (it.value == WILDCARD) &quot;&quot;</span>
<span class="fc" id="L40">                    else it.value.removePrefix(PARAMETER_PREFIX).removeSuffix(PARAMETER_SUFFIX)</span>
                }
<span class="fc" id="L42">                .toList()</span>
        else
<span class="fc" id="L44">            emptyList()</span>
    }

<span class="fc" id="L47">    val regex: Regex? by lazy {</span>
<span class="fc" id="L48">        pattern</span>
<span class="fc" id="L49">            .replace(&quot;(&quot;, &quot;(?:&quot;)</span>
<span class="fc bfc" id="L50" title="All 2 branches covered.">            .let {</span>
<span class="fc" id="L51">                when (Pair(hasWildcards, hasParameters)) {</span>
<span class="fc bfc" id="L52" title="All 2 branches covered.">                    Pair(true, true) -&gt;</span>
<span class="fc" id="L53">                        it.replace(WILDCARD, &quot;(.*?)&quot;).replace(PARAMETER_REGEX, &quot;(.+?)&quot;)</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">                    Pair(true, false) -&gt;</span>
<span class="fc" id="L55">                        it.replace(WILDCARD, &quot;(.*?)&quot;)</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">                    Pair(false, true) -&gt;</span>
<span class="fc" id="L57">                        it.replace(PARAMETER_REGEX, &quot;(.*?)&quot;)</span>
<span class="fc" id="L58">                    else -&gt; null</span>
                }
            }
<span class="fc" id="L61">            ?.let { Regex(&quot;$it$&quot;) }</span>
    }

<span class="fc" id="L64">    val segments by lazy { pattern.split(PLACEHOLDER_REGEX) }</span>

<span class="fc bfc" id="L66" title="All 4 branches covered.">    fun matches(requestUrl: String) = regex?.matches(requestUrl) ?: (pattern == requestUrl)</span>

    fun extractParameters(requestUrl: String): Map&lt;String, String&gt; {
<span class="fc bfc" id="L69" title="All 2 branches covered.">        require(matches(requestUrl)) { &quot;URL '$requestUrl' does not match path&quot; }</span>

<span class="fc" id="L71">        fun parameters(re: Regex) = re</span>
<span class="fc" id="L72">            .findGroups(requestUrl)</span>
<span class="fc" id="L73">            .mapIndexed { idx, (value) -&gt; parameterIndex[idx] to value }</span>
<span class="fc bfc" id="L74" title="All 4 branches covered.">            .filter { (first) -&gt; first != &quot;&quot; }</span>
<span class="fc" id="L75">            .toMap()</span>

<span class="fc" id="L77">        val re = regex</span>
<span class="pc bpc" id="L78" title="1 of 4 branches missed.">        return if (hasParameters &amp;&amp; re != null) parameters(re) else emptyMap()</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>