<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JettyServletAdapter.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">site</a> &gt; <a href="index.source.html" class="el_package">com.hexagonkt.http.server.jetty</a> &gt; <span class="el_source">JettyServletAdapter.kt</span></div><h1>JettyServletAdapter.kt</h1><pre class="source lang-java linenums">package com.hexagonkt.http.server.jetty

import com.hexagonkt.core.Jvm
import com.hexagonkt.core.fail
import com.hexagonkt.core.fieldsMapOf
import com.hexagonkt.http.model.HttpProtocol
import com.hexagonkt.http.model.HttpProtocol.HTTP
import com.hexagonkt.http.model.HttpProtocol.HTTP2
import com.hexagonkt.http.model.HttpProtocol.HTTPS
import com.hexagonkt.http.server.servlet.ServletFilter
import com.hexagonkt.http.server.HttpServer
import com.hexagonkt.http.server.HttpServerFeature
import com.hexagonkt.http.server.HttpServerFeature.ZIP
import com.hexagonkt.http.server.HttpServerPort
import com.hexagonkt.http.server.HttpServerSettings
import com.hexagonkt.http.server.handlers.PathHandler
import com.hexagonkt.http.server.handlers.path
import org.eclipse.jetty.alpn.server.ALPNServerConnectionFactory
import org.eclipse.jetty.http2.server.HTTP2ServerConnectionFactory
import org.eclipse.jetty.server.*
import org.eclipse.jetty.server.handler.gzip.GzipHandler
import org.eclipse.jetty.servlet.ServletContextHandler
import org.eclipse.jetty.servlet.ServletContextHandler.NO_SESSIONS
import org.eclipse.jetty.util.ssl.SslContextFactory
import org.eclipse.jetty.util.thread.QueuedThreadPool
import java.security.KeyStore
import java.util.EnumSet
import jakarta.servlet.DispatcherType
import org.eclipse.jetty.util.VirtualThreads
import org.eclipse.jetty.util.VirtualThreads.getDefaultVirtualThreadsExecutor
import org.eclipse.jetty.util.thread.ExecutorThreadPool
import org.eclipse.jetty.util.thread.ThreadPool
import java.util.concurrent.Executor
import java.util.concurrent.ThreadPoolExecutor
import org.eclipse.jetty.server.Server as JettyServer

/**
 * Implements [HttpServerPort] using [JettyServer].
 */
<span class="pc" id="L40">class JettyServletAdapter(</span>
<span class="fc" id="L41">    private val maxThreads: Int = 200,</span>
<span class="fc" id="L42">    private val minThreads: Int = 8,</span>

<span class="fc" id="L44">    private val acceptors: Int = -1,</span>
<span class="fc" id="L45">    private val selectors: Int = -1,</span>

<span class="fc" id="L47">    private val sendDateHeader: Boolean = false,</span>
<span class="fc" id="L48">    private val sendServerVersion: Boolean = false,</span>
<span class="fc" id="L49">    private val sendXPoweredBy: Boolean = false,</span>
<span class="pc" id="L50">    private val useVirtualThreads: Boolean = false,</span>
) : HttpServerPort {

    private var jettyServer: JettyServer? = null

<span class="fc" id="L55">    constructor() : this(</span>
<span class="fc" id="L56">        maxThreads = 200,</span>
<span class="fc" id="L57">        minThreads = 8,</span>

<span class="fc" id="L59">        acceptors = -1,</span>
<span class="fc" id="L60">        selectors = -1,</span>

<span class="fc" id="L62">        sendDateHeader = false,</span>
<span class="fc" id="L63">        sendServerVersion = false,</span>
<span class="fc" id="L64">        sendXPoweredBy = false,</span>
<span class="fc" id="L65">        useVirtualThreads = false,</span>
<span class="fc" id="L66">    )</span>

<span class="fc" id="L68">    init {</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">        if (useVirtualThreads)</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">            check(VirtualThreads.areSupported()) {</span>
<span class="fc" id="L71">                val jvm = &quot;JVM: ${Jvm.version}&quot;</span>
<span class="fc" id="L72">                &quot;Virtual threads not supported or not enabled (--enable-preview) $jvm&quot;</span>
            }
<span class="fc" id="L74">    }</span>

    override fun runtimePort(): Int =
<span class="pc bpc" id="L77" title="2 of 6 branches missed.">        ((jettyServer?.connectors?.get(0) ?: fail) as ServerConnector).localPort</span>

    override fun started() =
<span class="fc bfc" id="L80" title="All 2 branches covered.">        jettyServer?.isStarted ?: false</span>

    private fun createThreadPool(): ThreadPool =
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        if (useVirtualThreads) {</span>
<span class="nc" id="L84">            val virtualThreadPool = getDefaultVirtualThreadsExecutor()</span>
<span class="nc" id="L85">            val threadPool = ExecutorThreadPool(maxThreads, minThreads)</span>
<span class="nc" id="L86">            threadPool.virtualThreadsExecutor = virtualThreadPool</span>
<span class="nc" id="L87">            threadPool</span>
        }
        else {
<span class="fc" id="L90">            QueuedThreadPool(maxThreads, minThreads)</span>
<span class="fc" id="L91">        }</span>

    override fun startUp(server: HttpServer) {
<span class="fc" id="L94">        val settings = server.settings</span>
<span class="fc" id="L95">        val serverInstance = JettyServer(createThreadPool())</span>
<span class="fc" id="L96">        jettyServer = serverInstance</span>

<span class="fc" id="L98">        val pathHandler: PathHandler = path(settings.contextPath, server.handlers)</span>

<span class="fc" id="L100">        val context = createServerContext(settings)</span>
<span class="fc" id="L101">        val filter = ServletFilter(pathHandler, settings)</span>
<span class="fc" id="L102">        val filterBind = context.servletContext.addFilter(&quot;filters&quot;, filter)</span>
<span class="fc" id="L103">        val dispatcherTypes = EnumSet.allOf(DispatcherType::class.java)</span>
<span class="fc" id="L104">        filterBind.addMappingForUrlPatterns(dispatcherTypes, true, &quot;/*&quot;)</span>

<span class="fc" id="L106">        val serverConnector =</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">            if (settings.sslSettings != null) setupSsl(settings, serverInstance)</span>
<span class="fc" id="L108">            else ServerConnector(serverInstance, acceptors, selectors)</span>

<span class="fc" id="L110">        serverConnector.host = settings.bindAddress.hostName</span>
<span class="fc" id="L111">        serverConnector.port = settings.bindPort</span>
<span class="fc" id="L112">        serverConnector.connectionFactories</span>
<span class="fc" id="L113">            .filterIsInstance(HttpConnectionFactory::class.java)</span>
<span class="fc" id="L114">            .map { it.httpConfiguration }</span>
<span class="fc" id="L115">            .map {</span>
<span class="fc" id="L116">                it.sendDateHeader = sendDateHeader</span>
<span class="fc" id="L117">                it.sendServerVersion = sendServerVersion</span>
<span class="fc" id="L118">                it.sendXPoweredBy = sendXPoweredBy</span>
<span class="fc" id="L119">            }</span>

<span class="fc" id="L121">        serverInstance.connectors = arrayOf(serverConnector)</span>
<span class="fc" id="L122">        serverInstance.handler = context</span>
<span class="fc" id="L123">        serverInstance.stopAtShutdown = true</span>
<span class="fc" id="L124">        serverInstance.start()</span>
<span class="fc" id="L125">    }</span>

    override fun shutDown() {
<span class="fc bfc" id="L128" title="All 2 branches covered.">        jettyServer?.stop()</span>
<span class="fc" id="L129">    }</span>

    override fun supportedProtocols(): Set&lt;HttpProtocol&gt; =
<span class="fc" id="L132">        setOf(HTTP, HTTPS, HTTP2)</span>

    override fun supportedFeatures(): Set&lt;HttpServerFeature&gt; =
<span class="fc" id="L135">        setOf(ZIP)</span>

    override fun options(): Map&lt;String, *&gt; =
<span class="fc" id="L138">        fieldsMapOf(</span>
<span class="fc" id="L139">            JettyServletAdapter::maxThreads to maxThreads,</span>
<span class="fc" id="L140">            JettyServletAdapter::minThreads to minThreads,</span>
<span class="fc" id="L141">            JettyServletAdapter::acceptors to acceptors,</span>
<span class="fc" id="L142">            JettyServletAdapter::selectors to selectors,</span>
<span class="fc" id="L143">            JettyServletAdapter::sendDateHeader to sendDateHeader,</span>
<span class="fc" id="L144">            JettyServletAdapter::sendServerVersion to sendServerVersion,</span>
<span class="fc" id="L145">            JettyServletAdapter::sendXPoweredBy to sendXPoweredBy,</span>
<span class="fc" id="L146">            JettyServletAdapter::useVirtualThreads to useVirtualThreads,</span>
<span class="fc" id="L147">        )</span>

    private fun createServerContext(settings: HttpServerSettings): ServletContextHandler {

<span class="fc" id="L151">        val context = ServletContextHandler(NO_SESSIONS)</span>

<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (settings.zip)</span>
<span class="fc" id="L154">            context.insertHandler(GzipHandler())</span>

<span class="fc" id="L156">        return context</span>
    }

    private fun setupSsl(
        settings: HttpServerSettings, serverInstance: JettyServer): ServerConnector {

<span class="fc" id="L162">        val httpConfiguration = HttpConfiguration()</span>
<span class="fc" id="L163">        httpConfiguration.secureScheme = &quot;https&quot;</span>
<span class="fc" id="L164">        httpConfiguration.securePort = settings.bindPort</span>
<span class="fc" id="L165">        httpConfiguration.addCustomizer(SecureRequestCustomizer())</span>

<span class="fc" id="L167">        val sslContextFactory = SslContextFactory.Server()</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        val sslSettings = settings.sslSettings ?: fail</span>
<span class="fc" id="L169">        sslContextFactory.needClientAuth = sslSettings.clientAuth</span>

<span class="fc" id="L171">        val keyStore = sslSettings.keyStore</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (keyStore != null) {</span>
<span class="fc" id="L173">            val keyStorePassword = sslSettings.keyStorePassword</span>
<span class="fc" id="L174">            val keyStoreStream = keyStore.openStream()</span>
<span class="fc" id="L175">            sslContextFactory.keyStore = KeyStore.getInstance(&quot;pkcs12&quot;)</span>
<span class="fc" id="L176">            sslContextFactory.keyStore.load(keyStoreStream, keyStorePassword.toCharArray())</span>
<span class="fc" id="L177">            sslContextFactory.keyStorePassword = keyStorePassword</span>
        }

<span class="fc" id="L180">        val trustStore = sslSettings.trustStore</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        if (trustStore != null) {</span>
<span class="fc" id="L182">            val trustStorePassword = sslSettings.trustStorePassword</span>
<span class="fc" id="L183">            val trustStoreStream = trustStore.openStream()</span>
<span class="fc" id="L184">            sslContextFactory.trustStore = KeyStore.getInstance(&quot;pkcs12&quot;)</span>
<span class="fc" id="L185">            sslContextFactory.trustStore.load(trustStoreStream, trustStorePassword.toCharArray())</span>
<span class="fc" id="L186">            sslContextFactory.setTrustStorePassword(trustStorePassword)</span>
        }

<span class="fc bfc" id="L189" title="All 2 branches covered.">        return if (settings.protocol != HTTP2)</span>
<span class="fc" id="L190">            ServerConnector(</span>
<span class="fc" id="L191">                serverInstance,</span>
<span class="fc" id="L192">                SslConnectionFactory(sslContextFactory, &quot;http/1.1&quot;),</span>
<span class="fc" id="L193">                HttpConnectionFactory(httpConfiguration)</span>
            )
        else {
<span class="fc" id="L196">            val alpn = ALPNServerConnectionFactory()</span>
<span class="fc" id="L197">            ServerConnector(</span>
<span class="fc" id="L198">                serverInstance,</span>
<span class="fc" id="L199">                SslConnectionFactory(sslContextFactory, alpn.protocol),</span>
<span class="fc" id="L200">                alpn,</span>
<span class="fc" id="L201">                HTTP2ServerConnectionFactory(httpConfiguration),</span>
<span class="fc" id="L202">                HttpConnectionFactory(httpConfiguration)</span>
            )
        }
    }
<span class="nc" id="L206">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>