<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ServletFilter.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">site</a> &gt; <a href="index.source.html" class="el_package">com.hexagonkt.http.server.servlet</a> &gt; <span class="el_source">ServletFilter.kt</span></div><h1>ServletFilter.kt</h1><pre class="source lang-java linenums">package com.hexagonkt.http.server.servlet

import com.hexagonkt.core.logging.Logger
import com.hexagonkt.core.media.TextMedia
import com.hexagonkt.core.toText
import com.hexagonkt.http.bodyToBytes
import com.hexagonkt.http.server.HttpServerFeature.ASYNC
import com.hexagonkt.http.server.HttpServerSettings
import com.hexagonkt.http.server.handlers.PathHandler
import com.hexagonkt.http.server.model.HttpServerResponse
import jakarta.servlet.FilterChain
import jakarta.servlet.FilterConfig
import jakarta.servlet.http.Cookie
import jakarta.servlet.http.HttpFilter
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

<span class="fc" id="L22">class ServletFilter(</span>
    pathHandler: PathHandler,
<span class="fc" id="L24">    private val serverSettings: HttpServerSettings</span>
<span class="fc" id="L25">) : HttpFilter() {</span>

<span class="fc" id="L27">    private val logger: Logger = Logger(ServletFilter::class)</span>
<span class="fc" id="L28">    private val async: Boolean = serverSettings.features.contains(ASYNC)</span>

    private val handlers: Map&lt;String, PathHandler&gt; =
<span class="fc" id="L31">        pathHandler.byMethod().mapKeys { it.key.toString() }</span>

    override fun init(filterConfig: FilterConfig) {
<span class="fc" id="L34">        val filterName = filterConfig.filterName</span>
<span class="fc" id="L35">        val parameterNames = filterConfig.initParameterNames.toList().joinToString(&quot;, &quot;) {</span>
<span class="fc" id="L36">            &quot;$it = ${filterConfig.getInitParameter(it)}&quot;</span>
        }
<span class="fc" id="L38">        logger.info {</span>
<span class="fc" id="L39">            &quot;&quot;&quot;'$filterName' Servlet filter initialized.</span>
<span class="fc" id="L40">              |  * Context path: ${filterConfig.servletContext.contextPath}</span>
<span class="fc" id="L41">              |  * Parameters: $parameterNames</span>
<span class="fc" id="L42">              |  * Server settings: $serverSettings</span>
<span class="fc" id="L43">            &quot;&quot;&quot;.trimMargin()</span>
        }
<span class="fc" id="L45">    }</span>

    override fun destroy() {
<span class="fc" id="L48">        logger.info { &quot;Servlet filter destroyed&quot; }</span>
<span class="fc" id="L49">    }</span>

    override fun doFilter(
        request: HttpServletRequest, response: HttpServletResponse, chain: FilterChain) {

<span class="fc bfc" id="L54" title="All 2 branches covered.">        if (async) doFilterAsync(request, response)</span>
<span class="fc" id="L55">        else doFilter(request, response)</span>
<span class="fc" id="L56">    }</span>

    private fun doFilterAsync(request: HttpServletRequest, response: HttpServletResponse) {
<span class="fc" id="L59">        val asyncContext = request.startAsync()</span>

<span class="fc" id="L61">        CoroutineScope(Dispatchers.Default).launch {</span>
<span class="pc bpc" id="L62" title="2 of 4 branches missed.">            val handlerResponse = handlers[request.method]</span>
<span class="pc" id="L63">                ?.process(ServletRequestAdapter(request))</span>
<span class="nc" id="L64">                ?: HttpServerResponse()</span>

<span class="fc" id="L66">            try {</span>
<span class="fc" id="L67">                responseToServlet(handlerResponse, response)</span>
            }
<span class="fc" id="L69">            catch (e: Exception) {</span>
<span class="fc" id="L70">                response.addHeader(&quot;content-type&quot;, TextMedia.PLAIN.fullType)</span>
<span class="fc" id="L71">                response.status = 500</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">                withContext(Dispatchers.IO) {</span>
<span class="fc" id="L73">                    response.outputStream.write(e.toText().toByteArray())</span>
<span class="pc" id="L74">                }</span>
            }
            finally {
<span class="fc" id="L77">                asyncContext.complete()</span>
            }
<span class="fc" id="L79">        }</span>
<span class="fc" id="L80">    }</span>

    // TODO Only works on requests without payloads
//    private fun doFilterAsync2(request: HttpServletRequest, response: HttpServletResponse) {
//        val asyncContext = request.startAsync()
//
//        request.inputStream.setReadListener(object : ReadListener {
//            override fun onDataAvailable() {
//                // TODO Reads the data, but is not loaded on the request
//                request.inputStream.readAllBytes()
//            }
//
//            override fun onAllDataRead() {
//                val handlerResponse = handlers[request.method]
//                    ?.process(ServletRequestAdapter(request))
//                    ?: HttpServerResponse()
//
//                response.outputStream.setWriteListener(object : WriteListener {
//                    override fun onWritePossible() {
//                        responseToServlet(handlerResponse, response)
//                        asyncContext.complete()
//                    }
//
//                    override fun onError(t: Throwable?) {
//                        logger.error(t)
//                        response.addHeader(&quot;content-type&quot;, TextMedia.PLAIN.fullType)
//                        response.status = 500
//                        if (t != null)
//                            response.outputStream.write(t.toText().toByteArray())
//                        asyncContext.complete()
//                    }
//                })
//            }
//
//            override fun onError(t: Throwable?) {
//                logger.error(t)
//                asyncContext.complete()
//            }
//        })
//    }

    private fun doFilter(request: HttpServletRequest, response: HttpServletResponse) {

<span class="fc bfc" id="L123" title="All 4 branches covered.">        val handlerResponse = handlers[request.method]</span>
<span class="fc" id="L124">            ?.process(ServletRequestAdapter(request))</span>
<span class="fc" id="L125">            ?: HttpServerResponse()</span>

<span class="fc" id="L127">        try {</span>
<span class="fc" id="L128">            responseToServlet(handlerResponse, response)</span>
        }
<span class="fc" id="L130">        catch (e: Exception) {</span>
<span class="fc" id="L131">            response.addHeader(&quot;content-type&quot;, TextMedia.PLAIN.fullType)</span>
<span class="fc" id="L132">            response.status = 500</span>
<span class="fc" id="L133">            response.outputStream.write(e.toText().toByteArray())</span>
        }
        finally {
<span class="fc" id="L136">            response.outputStream.flush()</span>
        }
<span class="fc" id="L138">    }</span>

    private fun responseToServlet(
        response: HttpServerResponse, servletResponse: HttpServletResponse) {

<span class="fc" id="L143">        response.headers.allValues.forEach { (k, v) -&gt;</span>
<span class="fc" id="L144">            v.forEach { servletResponse.addHeader(k, it) }</span>
<span class="fc" id="L145">        }</span>

<span class="fc" id="L147">        response.cookies.forEach {</span>
<span class="fc" id="L148">            val cookie = Cookie(it.name, it.value).apply {</span>
<span class="fc" id="L149">                maxAge = it.maxAge.toInt()</span>
<span class="fc" id="L150">                secure = it.secure</span>
<span class="fc" id="L151">            }</span>
<span class="fc" id="L152">            servletResponse.addCookie(cookie)</span>
<span class="fc" id="L153">        }</span>

<span class="fc bfc" id="L155" title="All 2 branches covered.">        response.contentType?.let { servletResponse.addHeader(&quot;content-type&quot;, it.text) }</span>
<span class="fc" id="L156">        servletResponse.status = response.status.code</span>
        // TODO Handle different types: deferred values, strings, ints... flows
<span class="fc" id="L158">        servletResponse.outputStream.write(bodyToBytes(response.body))</span>
<span class="fc" id="L159">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>