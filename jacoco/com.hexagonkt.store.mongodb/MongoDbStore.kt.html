<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MongoDbStore.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hexagon_site</a> &gt; <a href="index.source.html" class="el_package">com.hexagonkt.store.mongodb</a> &gt; <span class="el_source">MongoDbStore.kt</span></div><h1>MongoDbStore.kt</h1><pre class="source lang-java linenums">package com.hexagonkt.store.mongodb

import com.hexagonkt.helpers.fail
import com.hexagonkt.helpers.filterEmpty
import com.hexagonkt.store.IndexOrder
import com.hexagonkt.store.IndexOrder.ASCENDING
import com.hexagonkt.store.Mapper
import com.hexagonkt.store.Store
import com.mongodb.ConnectionString
import com.mongodb.client.FindIterable
import com.mongodb.client.MongoClients
import com.mongodb.client.MongoCollection
import com.mongodb.client.MongoDatabase
import com.mongodb.client.model.Filters
import com.mongodb.client.model.IndexOptions
import com.mongodb.client.model.Indexes
import com.mongodb.client.model.ReplaceOptions
import com.mongodb.client.model.Updates
import org.bson.Document
import org.bson.conversions.Bson
import kotlin.reflect.KClass
import kotlin.reflect.KProperty1

<span class="pc" id="L24">class MongoDbStore&lt;T : Any, K : Any&gt;(</span>
<span class="fc" id="L25">    override val type: KClass&lt;T&gt;,</span>
<span class="fc" id="L26">    override val key: KProperty1&lt;T, K&gt;,</span>
<span class="fc" id="L27">    private val database: MongoDatabase,</span>
<span class="pc" id="L28">    override val name: String = type.java.simpleName,</span>
<span class="fc" id="L29">    override val mapper: Mapper&lt;T&gt; = MongoDbMapper(type, key)</span>
) : Store&lt;T, K&gt; {

    companion object {
<span class="fc" id="L33">        fun database(url: String): MongoDatabase = ConnectionString(url).let {</span>
<span class="pc bpc" id="L34" title="1 of 2 branches missed.">            MongoClients.create(it).getDatabase(it.database ?: fail)</span>
<span class="fc" id="L35">        }</span>
    }

<span class="fc" id="L38">    val collection: MongoCollection&lt;Document&gt; = this.database.getCollection(name)</span>

<span class="nc" id="L40">    constructor(</span>
<span class="nc" id="L41">        type: KClass&lt;T&gt;, key: KProperty1&lt;T, K&gt;, url: String, name: String = type.java.simpleName</span>
    ) :
<span class="pc" id="L43">        this(type, key, database(url), name)</span>

    override fun createIndex(unique: Boolean, fields: Map&lt;String, IndexOrder&gt;): String {
<span class="fc" id="L46">        val indexes = fields.entries.map {</span>
<span class="fc bfc" id="L47" title="All 2 branches covered.">            if (it.value == ASCENDING) Indexes.ascending(it.key)</span>
<span class="fc" id="L48">            else Indexes.descending(it.key)</span>
        }

<span class="fc" id="L51">        val name = fields.entries.joinToString(&quot;_&quot;) {</span>
<span class="fc" id="L52">            it.key + &quot;_&quot; + it.value.toString().lowercase()</span>
        }

<span class="fc" id="L55">        val compoundIndex = Indexes.compoundIndex(indexes)</span>
<span class="fc" id="L56">        val indexOptions = IndexOptions().unique(unique).background(true).name(name)</span>

<span class="fc" id="L58">        return collection.createIndex(compoundIndex, indexOptions)</span>
    }

    override fun insertOne(instance: T): K {
<span class="fc" id="L62">        collection.insertOne(map(instance))</span>
<span class="fc" id="L63">        return key.get(instance)</span>
    }

    override fun insertMany(instances: List&lt;T&gt;): List&lt;K&gt; {
<span class="fc" id="L67">        collection.insertMany(instances.map { instance -&gt; map(instance) })</span>
<span class="fc" id="L68">        return instances.map { key.get(it) }</span>
    }

    override fun saveOne(instance: T): K? {
<span class="fc" id="L72">        val filter = createKeyFilter(key.get(instance))</span>
<span class="fc" id="L73">        val options = ReplaceOptions().upsert(true)</span>
<span class="fc" id="L74">        val result = collection.replaceOne(filter, map(instance), options)</span>
<span class="fc" id="L75">        val upsertedId = result.upsertedId</span>

        @Suppress(&quot;UNCHECKED_CAST&quot;)
<span class="fc bfc" id="L78" title="All 2 branches covered.">        return if (upsertedId == null) null</span>
<span class="fc" id="L79">            else mapper.fromStore(key.name, upsertedId as Any) as K</span>
    }

    override fun saveMany(instances: List&lt;T&gt;): List&lt;K?&gt; =
<span class="fc" id="L83">        instances.map(this::saveOne)</span>

    override fun replaceOne(instance: T): Boolean {
<span class="fc" id="L86">        val document = map(instance)</span>
<span class="fc" id="L87">        val filter = createKeyFilter(key.get(instance))</span>
<span class="fc" id="L88">        val result = collection.replaceOne(filter, document)</span>
        // *NOTE* that 'modifiedCount' returns 0 for matched records with unchanged update values
<span class="fc bfc" id="L90" title="All 2 branches covered.">        return result.matchedCount == 1L</span>
    }

    override fun replaceMany(instances: List&lt;T&gt;): List&lt;T&gt; =
<span class="fc bfc" id="L94" title="All 4 branches covered.">        instances.mapNotNull { if (replaceOne(it)) it else null }</span>

    override fun updateOne(key: K, updates: Map&lt;String, *&gt;): Boolean {
<span class="pc bpc" id="L97" title="2 of 4 branches missed.">        require(updates.isNotEmpty())</span>
<span class="fc" id="L98">        val filter = createKeyFilter(key)</span>
<span class="fc" id="L99">        val update = createUpdate(updates)</span>
<span class="fc" id="L100">        val result = collection.updateOne(filter, update)</span>
        // *NOTE* that 'modifiedCount' returns 0 for matched records with unchanged update values
<span class="fc bfc" id="L102" title="All 2 branches covered.">        return result.matchedCount == 1L</span>
    }

    override fun updateMany(filter: Map&lt;String, *&gt;, updates: Map&lt;String, *&gt;): Long {
<span class="pc bpc" id="L106" title="2 of 4 branches missed.">        require(updates.isNotEmpty())</span>
<span class="fc" id="L107">        val updateFilter = createFilter(filter)</span>
<span class="fc" id="L108">        val update = createUpdate(updates)</span>
<span class="fc" id="L109">        val result = collection.updateMany(updateFilter, update)</span>
        // *NOTE* that 'modifiedCount' returns 0 for matched records with unchanged update values
<span class="fc" id="L111">        return result.matchedCount</span>
    }

    override fun deleteOne(id: K): Boolean {
<span class="fc" id="L115">        val filter = createKeyFilter(id)</span>
<span class="fc" id="L116">        val result = collection.deleteOne(filter)</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        return result.deletedCount == 1L</span>
    }

    override fun deleteMany(filter: Map&lt;String, *&gt;): Long {
<span class="fc" id="L121">        val deleteFilter = createFilter(filter)</span>
<span class="fc" id="L122">        val result = collection.deleteMany(deleteFilter)</span>
<span class="fc" id="L123">        return result.deletedCount</span>
    }

    override fun findOne(key: K): T? {
<span class="fc bfc" id="L127" title="All 2 branches covered.">        val result = collection.find(createKeyFilter(key)).first()?.filterEmpty()</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">        return if (result == null) null else mapper.fromStore(result as Map&lt;String, Any&gt;)</span>
    }

    override fun findOne(key: K, fields: List&lt;String&gt;): Map&lt;String, *&gt;? {
<span class="fc" id="L132">        val filter = createKeyFilter(key)</span>
<span class="fc" id="L133">        val result = collection</span>
<span class="fc" id="L134">            .find(filter)</span>
<span class="fc" id="L135">            .projection(createProjection(fields))</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">            .first()?.filterEmpty()</span>

<span class="fc bfc" id="L138" title="All 2 branches covered.">        return result?.mapValues { mapper.fromStore(it.key, it.value) }</span>
    }

    override fun findMany(
        filter: Map&lt;String, *&gt;,
        limit: Int?,
        skip: Int?,
        sort: Map&lt;String, Boolean&gt;
    ): List&lt;T&gt; {

<span class="fc" id="L148">        val findFilter = createFilter(filter)</span>
<span class="fc" id="L149">        val findSort = createSort(sort)</span>
<span class="fc" id="L150">        val query = collection.find(findFilter).sort(findSort)</span>

<span class="fc" id="L152">        pageQuery(limit, query, skip)</span>

<span class="fc" id="L154">        val result = query.into(ArrayList())</span>
<span class="fc" id="L155">        return result.map { mapper.fromStore(it.filterEmpty()) }</span>
    }

    override fun findMany(
        filter: Map&lt;String, *&gt;,
        fields: List&lt;String&gt;,
        limit: Int?,
        skip: Int?,
        sort: Map&lt;String, Boolean&gt;
    ): List&lt;Map&lt;String, *&gt;&gt; {

<span class="fc" id="L166">        val findFilter = createFilter(filter)</span>
<span class="fc" id="L167">        val projection = createProjection(fields)</span>
<span class="fc" id="L168">        val findSort = createSort(sort)</span>
<span class="fc" id="L169">        val query = collection.find(findFilter).projection(projection).sort(findSort)</span>

<span class="fc" id="L171">        pageQuery(limit, query, skip)</span>

<span class="fc" id="L173">        val result = query.into(ArrayList())</span>

<span class="fc" id="L175">        return result.map { resultMap -&gt;</span>
<span class="fc" id="L176">            resultMap</span>
<span class="fc" id="L177">                .map { pair -&gt; pair.key to mapper.fromStore(pair.key, pair.value) }</span>
<span class="fc" id="L178">                .toMap()</span>
        }
    }

    override fun count(filter: Map&lt;String, *&gt;): Long {
<span class="fc" id="L183">        val countFilter = createFilter(filter)</span>
<span class="fc" id="L184">        return collection.countDocuments(countFilter)</span>
    }

    override fun drop() {
<span class="fc" id="L188">        collection.drop()</span>
<span class="fc" id="L189">    }</span>

    private fun pageQuery(limit: Int?, query: FindIterable&lt;Document&gt;, skip: Int?) {
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (limit != null)</span>
<span class="fc" id="L193">            query.limit(limit)</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (skip != null)</span>
<span class="fc" id="L196">            query.skip(skip)</span>
<span class="fc" id="L197">    }</span>

<span class="fc" id="L199">    private fun map(instance: T): Document = Document(mapper.toStore(instance))</span>

<span class="fc" id="L201">    private fun createKeyFilter(key: K) = Filters.eq(&quot;_id&quot;, key)</span>

<span class="fc" id="L203">    private fun createFilter(filter: Map&lt;String, *&gt;): Bson = filter</span>
<span class="fc" id="L204">        .filterEmpty()</span>
<span class="fc" id="L205">        .filter {</span>
<span class="fc" id="L206">            val firstKeySegment = it.key.split(&quot;.&quot;)[0]</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">            mapper.fields.keys.contains(firstKeySegment)</span>
        }
<span class="fc" id="L209">        .map {</span>
<span class="fc" id="L210">            val keyFields = it.key.split(&quot;:&quot;)</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            val key = keyFields.firstOrNull() ?: fail</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">            val collectionKey = if (key == this.key.name) &quot;_id&quot; else key</span>
<span class="fc" id="L213">            val operator = keyFields.getOrNull(1)</span>
<span class="fc" id="L214">            val value = it.value</span>

<span class="fc" id="L216">            when {</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                value is List&lt;*&gt; -&gt;</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">                    if (value.size &gt; 1) Filters.`in`(collectionKey, value)</span>
<span class="nc" id="L219">                    else Filters.eq(collectionKey, value.first())</span>
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">                operator != null -&gt;</span>
<span class="nc bnc" id="L221" title="All 6 branches missed.">                    when (operator) {</span>
<span class="nc" id="L222">                        &quot;gt&quot; -&gt; Filters.gt(collectionKey, value)</span>
<span class="nc" id="L223">                        &quot;gte&quot; -&gt; Filters.gte(collectionKey, value)</span>
<span class="nc" id="L224">                        &quot;lt&quot; -&gt; Filters.lt(collectionKey, value)</span>
<span class="nc" id="L225">                        &quot;lte&quot; -&gt; Filters.lte(collectionKey, value)</span>
<span class="nc" id="L226">                        &quot;re&quot; -&gt; Filters.regex(collectionKey, value.toString())</span>
<span class="nc" id="L227">                        else -&gt; Filters.eq(collectionKey, value)</span>
                    }
                else -&gt;
<span class="fc" id="L230">                    Filters.eq(collectionKey, value)</span>
            }
        }
<span class="fc" id="L233">        .let {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">            if (it.isEmpty()) Document()</span>
<span class="fc" id="L235">            else Filters.and(it)</span>
<span class="fc" id="L236">        }</span>

    private fun createUpdate(update: Map&lt;String, *&gt;): Bson =
<span class="fc" id="L239">        Updates.combine(</span>
<span class="fc" id="L240">            update</span>
<span class="fc" id="L241">                .filterEmpty()</span>
<span class="fc" id="L242">                .mapValues { mapper.toStore(it.key, it.value) }</span>
<span class="fc" id="L243">                .map { Updates.set(it.key, it.value) }</span>
<span class="fc" id="L244">        )</span>

    private fun createProjection(fields: List&lt;String&gt;): Bson =
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (fields.isEmpty()) Document()</span>
        else
<span class="fc" id="L249">            fields</span>
<span class="fc" id="L250">                .asSequence()</span>
<span class="fc" id="L251">                .filter { fields.contains(it) }</span>
<span class="fc" id="L252">                .map { it to 1 }</span>
<span class="fc" id="L253">                .toMap()</span>
<span class="fc" id="L254">                .toDocument()</span>
<span class="fc" id="L255">                .append(&quot;_id&quot;, 0)</span>

    private fun createSort(fields: Map&lt;String, Boolean&gt;): Bson =
<span class="fc" id="L258">        fields</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">            .filter { fields.contains(it.key) }</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">            .mapValues { if (it.value) -1 else 1 }</span>
<span class="fc" id="L261">            .toDocument()</span>

<span class="fc" id="L263">    private fun Map&lt;String, *&gt;.toDocument() = Document(this)</span>
<span class="fc" id="L264">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>