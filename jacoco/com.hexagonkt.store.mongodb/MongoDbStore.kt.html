<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MongoDbStore.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hexagon_site</a> &gt; <a href="index.source.html" class="el_package">com.hexagonkt.store.mongodb</a> &gt; <span class="el_source">MongoDbStore.kt</span></div><h1>MongoDbStore.kt</h1><pre class="source lang-java linenums">package com.hexagonkt.store.mongodb

import com.hexagonkt.helpers.fail
import com.hexagonkt.helpers.filterEmpty
import com.hexagonkt.store.IndexOrder
import com.hexagonkt.store.IndexOrder.ASCENDING
import com.hexagonkt.store.Mapper
import com.hexagonkt.store.Store
import com.mongodb.ConnectionString
import com.mongodb.client.*
import com.mongodb.client.model.*
import org.bson.Document
import org.bson.conversions.Bson
import kotlin.reflect.KClass
import kotlin.reflect.KProperty1

<span class="pc" id="L17">class MongoDbStore&lt;T : Any, K : Any&gt;(</span>
<span class="fc" id="L18">    override val type: KClass&lt;T&gt;,</span>
<span class="fc" id="L19">    override val key: KProperty1&lt;T, K&gt;,</span>
    private val database: MongoDatabase,
<span class="pc" id="L21">    override val name: String = type.java.simpleName,</span>
<span class="fc" id="L22">    override val mapper: Mapper&lt;T&gt; = MongoDbMapper(type, key)</span>
) : Store&lt;T, K&gt; {

    companion object {
<span class="fc" id="L26">        fun database(url: String): MongoDatabase = ConnectionString(url).let {</span>
<span class="pc bpc" id="L27" title="1 of 2 branches missed.">            MongoClients.create(it).getDatabase(it.database ?: fail)</span>
<span class="fc" id="L28">        }</span>
    }

<span class="fc" id="L31">    val collection: MongoCollection&lt;Document&gt; = this.database.getCollection(name)</span>

<span class="fc" id="L33">    constructor(</span>
<span class="nc" id="L34">        type: KClass&lt;T&gt;, key: KProperty1&lt;T, K&gt;, url: String, name: String = type.java.simpleName</span>
    ) :
<span class="fc" id="L36">        this(type, key, database(url), name)</span>

    override fun createIndex(unique: Boolean, fields: Map&lt;String, IndexOrder&gt;): String {
<span class="fc" id="L39">        val indexes = fields.entries.map {</span>
<span class="fc bfc" id="L40" title="All 2 branches covered.">            if (it.value == ASCENDING) Indexes.ascending(it.key)</span>
<span class="fc" id="L41">            else Indexes.descending(it.key)</span>
        }

<span class="fc" id="L44">        val name = fields.entries.joinToString(&quot;_&quot;) {</span>
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">            it.key + &quot;_&quot; + it.value.toString().toLowerCase()</span>
        }

<span class="fc" id="L48">        val compoundIndex = Indexes.compoundIndex(indexes)</span>
<span class="fc" id="L49">        val indexOptions = IndexOptions().unique(unique).background(true).name(name)</span>

<span class="fc" id="L51">        return collection.createIndex(compoundIndex, indexOptions)</span>
    }

    override fun insertOne(instance: T): K {
<span class="fc" id="L55">        collection.insertOne(map(instance))</span>
<span class="fc" id="L56">        return key.get(instance)</span>
    }

    override fun insertMany(instances: List&lt;T&gt;): List&lt;K&gt; {
<span class="fc" id="L60">        collection.insertMany(instances.map { instance -&gt; map(instance) })</span>
<span class="fc" id="L61">        return instances.map { key.get(it) }</span>
    }

    override fun saveOne(instance: T): K? {
<span class="fc" id="L65">        val filter = createKeyFilter(key.get(instance))</span>
<span class="fc" id="L66">        val options = ReplaceOptions().upsert(true)</span>
<span class="fc" id="L67">        val result = collection.replaceOne(filter, map(instance), options)</span>
<span class="fc" id="L68">        val upsertedId = result.upsertedId</span>

        @Suppress(&quot;UNCHECKED_CAST&quot;)
<span class="fc bfc" id="L71" title="All 2 branches covered.">        return if (upsertedId == null) null</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">            else mapper.fromStore(key.name, upsertedId as Any) as K</span>
    }

    override fun saveMany(instances: List&lt;T&gt;): List&lt;K?&gt; =
<span class="fc" id="L76">        instances.map(this::saveOne)</span>

    override fun replaceOne(instance: T): Boolean {
<span class="fc" id="L79">        val document = map(instance)</span>
<span class="fc" id="L80">        val filter = createKeyFilter(key.get(instance))</span>
<span class="fc" id="L81">        val result = collection.replaceOne(filter, document)</span>
        // *NOTE* that 'modifiedCount' returns 0 for matched records with unchanged update values
<span class="fc bfc" id="L83" title="All 2 branches covered.">        return result.matchedCount == 1L</span>
    }

    override fun replaceMany(instances: List&lt;T&gt;): List&lt;T&gt; =
<span class="fc bfc" id="L87" title="All 4 branches covered.">        instances.mapNotNull { if (replaceOne(it)) it else null }</span>

    override fun updateOne(key: K, updates: Map&lt;String, *&gt;): Boolean {
<span class="pc bpc" id="L90" title="2 of 4 branches missed.">        require(updates.isNotEmpty())</span>
<span class="fc" id="L91">        val filter = createKeyFilter(key)</span>
<span class="fc" id="L92">        val update = createUpdate(updates)</span>
<span class="fc" id="L93">        val result = collection.updateOne(filter, update)</span>
        // *NOTE* that 'modifiedCount' returns 0 for matched records with unchanged update values
<span class="fc bfc" id="L95" title="All 2 branches covered.">        return result.matchedCount == 1L</span>
    }

    override fun updateMany(filter: Map&lt;String, *&gt;, updates: Map&lt;String, *&gt;): Long {
<span class="pc bpc" id="L99" title="2 of 4 branches missed.">        require(updates.isNotEmpty())</span>
<span class="fc" id="L100">        val updateFilter = createFilter(filter)</span>
<span class="fc" id="L101">        val update = createUpdate(updates)</span>
<span class="fc" id="L102">        val result = collection.updateMany(updateFilter, update)</span>
        // *NOTE* that 'modifiedCount' returns 0 for matched records with unchanged update values
<span class="fc" id="L104">        return result.matchedCount</span>
    }

    override fun deleteOne(id: K): Boolean {
<span class="fc" id="L108">        val filter = createKeyFilter(id)</span>
<span class="fc" id="L109">        val result = collection.deleteOne(filter)</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        return result.deletedCount == 1L</span>
    }

    override fun deleteMany(filter: Map&lt;String, *&gt;): Long {
<span class="fc" id="L114">        val deleteFilter = createFilter(filter)</span>
<span class="fc" id="L115">        val result = collection.deleteMany(deleteFilter)</span>
<span class="fc" id="L116">        return result.deletedCount</span>
    }

    override fun findOne(key: K): T? {
<span class="fc bfc" id="L120" title="All 2 branches covered.">        val result = collection.find(createKeyFilter(key)).first()?.filterEmpty()</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        return if (result == null) null else mapper.fromStore(result as Map&lt;String, Any&gt;)</span>
    }

    override fun findOne(key: K, fields: List&lt;String&gt;): Map&lt;String, *&gt;? {
<span class="fc" id="L125">        val filter = createKeyFilter(key)</span>
<span class="fc" id="L126">        val result = collection</span>
<span class="fc" id="L127">            .find(filter)</span>
<span class="fc" id="L128">            .projection(createProjection(fields))</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">            .first()?.filterEmpty()</span>

<span class="fc bfc" id="L131" title="All 2 branches covered.">        return result?.mapValues { mapper.fromStore(it.key, it.value) }</span>
    }

    override fun findMany(
        filter: Map&lt;String, *&gt;,
        limit: Int?,
        skip: Int?,
        sort: Map&lt;String, Boolean&gt;
    ): List&lt;T&gt; {

<span class="fc" id="L141">        val findFilter = createFilter(filter)</span>
<span class="fc" id="L142">        val findSort = createSort(sort)</span>
<span class="fc" id="L143">        val query = collection.find(findFilter).sort(findSort)</span>

<span class="fc" id="L145">        pageQuery(limit, query, skip)</span>

<span class="fc" id="L147">        val result = query.into(ArrayList())</span>
<span class="fc" id="L148">        return result.map { mapper.fromStore(it.filterEmpty()) }</span>
    }

    override fun findMany(
        filter: Map&lt;String, *&gt;,
        fields: List&lt;String&gt;,
        limit: Int?,
        skip: Int?,
        sort: Map&lt;String, Boolean&gt;
    ): List&lt;Map&lt;String, *&gt;&gt; {

<span class="fc" id="L159">        val findFilter = createFilter(filter)</span>
<span class="fc" id="L160">        val projection = createProjection(fields)</span>
<span class="fc" id="L161">        val findSort = createSort(sort)</span>
<span class="fc" id="L162">        val query = collection.find(findFilter).projection(projection).sort(findSort)</span>

<span class="fc" id="L164">        pageQuery(limit, query, skip)</span>

<span class="fc" id="L166">        val result = query.into(ArrayList())</span>

<span class="fc" id="L168">        return result.map { resultMap -&gt;</span>
<span class="fc" id="L169">            resultMap</span>
<span class="fc" id="L170">                .map { pair -&gt; pair.key to mapper.fromStore(pair.key, pair.value) }</span>
<span class="fc" id="L171">                .toMap()</span>
        }
    }

    override fun count(filter: Map&lt;String, *&gt;): Long {
<span class="fc" id="L176">        val countFilter = createFilter(filter)</span>
<span class="fc" id="L177">        return collection.countDocuments(countFilter)</span>
    }

    override fun drop() {
<span class="fc" id="L181">        collection.drop()</span>
<span class="fc" id="L182">    }</span>

    private fun pageQuery(limit: Int?, query: FindIterable&lt;Document&gt;, skip: Int?) {
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (limit != null)</span>
<span class="fc" id="L186">            query.limit(limit)</span>

<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (skip != null)</span>
<span class="fc" id="L189">            query.skip(skip)</span>
<span class="fc" id="L190">    }</span>

<span class="fc" id="L192">    private fun map(instance: T): Document = Document(mapper.toStore(instance))</span>

<span class="fc" id="L194">    private fun createKeyFilter(key: K) = Filters.eq(&quot;_id&quot;, key)</span>

<span class="fc" id="L196">    private fun createFilter(filter: Map&lt;String, *&gt;): Bson = filter</span>
<span class="fc" id="L197">        .filterEmpty()</span>
<span class="fc" id="L198">        .filter {</span>
<span class="fc" id="L199">            val firstKeySegment = it.key.split(&quot;.&quot;)[0]</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">            mapper.fields.keys.contains(firstKeySegment)</span>
        }
<span class="fc" id="L202">        .map {</span>
<span class="fc" id="L203">            val keyFields = it.key.split(&quot;:&quot;)</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            val key = keyFields.firstOrNull() ?: fail</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">            val collectionKey = if (key == this.key.name) &quot;_id&quot; else key</span>
<span class="fc" id="L206">            val operator = keyFields.getOrNull(1)</span>
<span class="fc" id="L207">            val value = it.value</span>

<span class="fc" id="L209">            when {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                value is List&lt;*&gt; -&gt;</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">                    if (value.size &gt; 1) Filters.`in`(collectionKey, value)</span>
<span class="nc" id="L212">                    else Filters.eq(collectionKey, value.first())</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">                operator != null -&gt;</span>
<span class="nc bnc" id="L214" title="All 6 branches missed.">                    when (operator) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                        &quot;gt&quot; -&gt; Filters.gt(collectionKey, value)</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                        &quot;gte&quot; -&gt; Filters.gte(collectionKey, value)</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">                        &quot;lt&quot; -&gt; Filters.lt(collectionKey, value)</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">                        &quot;lte&quot; -&gt; Filters.lte(collectionKey, value)</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">                        &quot;re&quot; -&gt; Filters.regex(collectionKey, value.toString())</span>
<span class="nc" id="L220">                        else -&gt; Filters.eq(collectionKey, value)</span>
                    }
                else -&gt;
<span class="fc" id="L223">                    Filters.eq(collectionKey, value)</span>
            }
        }
<span class="fc" id="L226">        .let {</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">            if (it.isEmpty()) Document()</span>
<span class="fc" id="L228">            else Filters.and(it)</span>
<span class="fc" id="L229">        }</span>

    private fun createUpdate(update: Map&lt;String, *&gt;): Bson =
<span class="fc" id="L232">        Updates.combine(</span>
<span class="fc" id="L233">            update</span>
<span class="fc" id="L234">                .filterEmpty()</span>
<span class="fc" id="L235">                .mapValues { mapper.toStore(it.key, it.value) }</span>
<span class="fc" id="L236">                .map { Updates.set(it.key, it.value) }</span>
<span class="fc" id="L237">        )</span>

    private fun createProjection(fields: List&lt;String&gt;): Bson =
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (fields.isEmpty()) Document()</span>
        else
<span class="fc" id="L242">            fields</span>
<span class="fc" id="L243">                .asSequence()</span>
<span class="fc" id="L244">                .filter { fields.contains(it) }</span>
<span class="fc" id="L245">                .map { it to 1 }</span>
<span class="fc" id="L246">                .toMap()</span>
<span class="fc" id="L247">                .toDocument()</span>
<span class="fc" id="L248">                .append(&quot;_id&quot;, 0)</span>

    private fun createSort(fields: Map&lt;String, Boolean&gt;): Bson =
<span class="fc" id="L251">        fields</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">            .filter { fields.contains(it.key) }</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">            .mapValues { if (it.value) -1 else 1 }</span>
<span class="fc" id="L254">            .toDocument()</span>

<span class="fc" id="L256">    private fun Map&lt;String, *&gt;.toDocument() = Document(this)</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>