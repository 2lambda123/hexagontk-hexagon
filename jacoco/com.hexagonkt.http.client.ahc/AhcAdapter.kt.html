<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AhcAdapter.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hexagon_site</a> &gt; <a href="index.source.html" class="el_package">com.hexagonkt.http.client.ahc</a> &gt; <span class="el_source">AhcAdapter.kt</span></div><h1>AhcAdapter.kt</h1><pre class="source lang-java linenums">package com.hexagonkt.http.client.ahc

import com.hexagonkt.logging.Logger
import com.hexagonkt.helpers.ensureSize
import com.hexagonkt.helpers.fail
import com.hexagonkt.serialization.SerializationManager.formatOf
import com.hexagonkt.serialization.serialize
import com.hexagonkt.http.Cookie
import com.hexagonkt.http.Method
import com.hexagonkt.http.Method.*
import com.hexagonkt.http.client.*
import io.netty.handler.codec.http.cookie.DefaultCookie
import io.netty.handler.ssl.SslContext
import io.netty.handler.ssl.SslContextBuilder.forClient as sslContextBuilderClient
import org.asynchttpclient.BoundRequestBuilder
import io.netty.handler.ssl.util.InsecureTrustManagerFactory.INSTANCE as InsecureTrustManager
import org.asynchttpclient.DefaultAsyncHttpClient
import org.asynchttpclient.DefaultAsyncHttpClientConfig.Builder
import org.asynchttpclient.request.body.multipart.InputStreamPart
import org.asynchttpclient.request.body.multipart.StringPart
import org.asynchttpclient.request.body.multipart.Part as AhcPart
import java.io.File
import java.net.URL
import java.nio.charset.Charset
import java.nio.charset.StandardCharsets.UTF_8
import java.security.KeyStore
import java.security.KeyStore.PasswordProtection
import java.security.KeyStore.PrivateKeyEntry
import java.security.cert.X509Certificate
import java.util.*
import java.util.Base64.Encoder

/**
 * Client to use other REST services.
 */
<span class="fc" id="L36">class AhcAdapter : ClientPort {</span>

<span class="fc" id="L38">    private val base64encoder: Encoder by lazy { Base64.getEncoder() }</span>

    private var authorization: String? = null

    private lateinit var ssl: ClientSettings

<span class="fc" id="L44">    private val log: Logger = Logger(this::class)</span>

<span class="fc" id="L46">    private val ahcClient: DefaultAsyncHttpClient by lazy {</span>
<span class="fc" id="L47">        DefaultAsyncHttpClient(</span>
<span class="fc" id="L48">            Builder()</span>
<span class="fc" id="L49">                .setConnectTimeout(5000)</span>
<span class="fc" id="L50">                .setSslContext(sslContext(ssl))</span>
<span class="fc" id="L51">                .setKeepEncodingHeader(true)</span>
<span class="fc" id="L52">                .build()</span>
        )
    }

<span class="fc" id="L56">    private fun sslContext(settings: ClientSettings): SslContext = sslContextBuilderClient().let {</span>
<span class="fc" id="L57">        when {</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">            settings.insecure -&gt;</span>
<span class="fc" id="L59">                it.trustManager(InsecureTrustManager).build()</span>

<span class="fc bfc" id="L61" title="All 2 branches covered.">            settings.sslSettings != null -&gt; {</span>
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">                val sslSettings = settings.sslSettings ?: fail</span>
<span class="fc" id="L63">                val keyStore = sslSettings.keyStore</span>
<span class="fc" id="L64">                val trustStore = sslSettings.trustStore</span>

<span class="fc" id="L66">                var sslContextBuilder = it</span>

<span class="fc bfc" id="L68" title="All 2 branches covered.">                if (keyStore != null) {</span>
<span class="fc" id="L69">                    val password = sslSettings.keyStorePassword</span>
<span class="fc" id="L70">                    val store = keyStore(keyStore, password)</span>
<span class="fc" id="L71">                    val passwordProtection = PasswordProtection(password.toCharArray())</span>
<span class="fc" id="L72">                    val key = store</span>
<span class="fc" id="L73">                        .aliases()</span>
<span class="fc" id="L74">                        .toList()</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">                        .filter { alias -&gt; store.isKeyEntry(alias) }</span>
<span class="fc" id="L76">                        .mapNotNull { alias -&gt;</span>
<span class="fc" id="L77">                            store.getEntry(alias, passwordProtection) as PrivateKeyEntry</span>
                        }
<span class="fc" id="L79">                        .ensureSize(1..1)</span>
<span class="fc" id="L80">                        .first()</span>

<span class="fc" id="L82">                    val certificateChain = key.certificateChain</span>
<span class="fc" id="L83">                        .toList()</span>
<span class="fc" id="L84">                        .mapNotNull { certificate -&gt; certificate as X509Certificate }</span>
<span class="fc" id="L85">                        .toTypedArray()</span>

<span class="fc" id="L87">                    sslContextBuilder = sslContextBuilder</span>
<span class="fc" id="L88">                        .keyManager(key.privateKey, *certificateChain)</span>
                }

<span class="fc bfc" id="L91" title="All 2 branches covered.">                if (trustStore != null) {</span>
<span class="fc" id="L92">                    val store = keyStore(trustStore, sslSettings.trustStorePassword)</span>
<span class="fc" id="L93">                    val certs = store</span>
<span class="fc" id="L94">                        .aliases()</span>
<span class="fc" id="L95">                        .toList()</span>
<span class="fc" id="L96">                        .mapNotNull { alias -&gt; store.getCertificate(alias) as X509Certificate }</span>
<span class="fc" id="L97">                        .toTypedArray()</span>

<span class="fc" id="L99">                    sslContextBuilder = sslContextBuilder.trustManager(*certs)</span>
                }

<span class="fc" id="L102">                sslContextBuilder.build()</span>
            }

            else -&gt;
<span class="fc" id="L106">                it.build()</span>
        }
<span class="fc" id="L108">    }</span>

    private fun keyStore(url: URL, password: String): KeyStore {
<span class="fc" id="L111">        val keyStore = KeyStore.getInstance(&quot;pkcs12&quot;)</span>
<span class="fc" id="L112">        keyStore.load(url.openStream(), password.toCharArray())</span>
<span class="fc" id="L113">        return keyStore</span>
    }

    override fun send(client: Client, request: Request): Response {

<span class="fc" id="L118">        val settings: ClientSettings = client.settings</span>
<span class="fc" id="L119">        val ahcRequest = createRequest(client, request)</span>
<span class="fc" id="L120">        val bodyValue = createBodyValue(request.body, request.contentType)</span>

<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (bodyValue != null)</span>
<span class="fc" id="L123">            ahcRequest.setBody(bodyValue)</span>

<span class="fc" id="L125">        (settings.headers + request.headers).forEach { ahcRequest.addHeader(it.key, it.value) }</span>

<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (settings.useCookies)</span>
<span class="fc" id="L128">            client.cookies.forEach {</span>
<span class="fc" id="L129">                ahcRequest.addCookie(DefaultCookie(it.value.name, it.value.value))</span>
<span class="fc" id="L130">            }</span>

<span class="fc" id="L132">        val response = ahcRequest.execute().get()</span>

<span class="fc bfc" id="L134" title="All 2 branches covered.">        if (settings.useCookies) {</span>
<span class="fc" id="L135">            response.cookies.forEach {</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">                if (it.value() == &quot;&quot;)</span>
<span class="fc" id="L137">                    client.cookies.remove(it.name())</span>
                else
<span class="fc" id="L139">                    client.cookies[it.name()] = Cookie(it.name(), it.value())</span>
<span class="fc" id="L140">            }</span>
        }

        // TODO Make header lookup case insensitive (and add tests)
<span class="fc" id="L144">        val returnHeaders: MutableMap&lt;String, List&lt;String&gt;&gt; = HashMap(</span>
<span class="fc" id="L145">            response.headers.names()</span>
<span class="fc" id="L146">                .map { it to response.headers.getAll(it) }</span>
<span class="fc" id="L147">                .toMap()</span>
        )

<span class="fc" id="L150">        return response.let {</span>
<span class="fc" id="L151">            Response(</span>
<span class="fc" id="L152">                status = it.statusCode,</span>
<span class="fc" id="L153">                body = it.responseBody,</span>
<span class="fc" id="L154">                headers = returnHeaders,</span>
<span class="fc" id="L155">                contentType = it.contentType,</span>
<span class="fc" id="L156">                inputStream = it.responseBodyAsStream</span>
            )
        }
    }

    private fun createBodyValue(body: Any?, contentType: String?): String? =
<span class="fc" id="L162">        when (body) {</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            null -&gt; null</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">            is File -&gt; Base64.getEncoder().encodeToString(body.readBytes())</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            is String -&gt; body.toString()</span>
            else -&gt;
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">                if (contentType == null) body.toString()</span>
<span class="fc" id="L168">                else body.serialize(formatOf(contentType))</span>
<span class="fc" id="L169">        }</span>

    private fun createRequest(
        cl: Client, request: Request): BoundRequestBuilder {

<span class="fc" id="L174">        val method: Method = request.method</span>
<span class="fc" id="L175">        val path: String = cl.endpoint + request.path.pattern</span>
<span class="fc" id="L176">        val settings: ClientSettings = cl.settings</span>
<span class="fc" id="L177">        val contentType: String? = request.contentType</span>
<span class="fc" id="L178">        val parts: List&lt;AhcPart&gt; = request.parts.values.toList().map {</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            if (it.submittedFileName == null)</span>
<span class="fc" id="L180">                StringPart(it.name, it.inputStream.reader().readText())</span>
            else
<span class="fc" id="L182">                InputStreamPart(it.name, it.inputStream, it.submittedFileName)</span>
        }

<span class="fc" id="L185">        ssl = cl.settings</span>

<span class="fc bfc" id="L187" title="All 8 branches covered.">        val req = when (method) {</span>
<span class="fc" id="L188">            GET -&gt; ahcClient.prepareGet(path)</span>
<span class="fc" id="L189">            HEAD -&gt; ahcClient.prepareHead(path)</span>
<span class="fc" id="L190">            POST -&gt; ahcClient.preparePost(path)</span>
<span class="fc" id="L191">            PUT -&gt; ahcClient.preparePut(path)</span>
<span class="fc" id="L192">            DELETE -&gt; ahcClient.prepareDelete(path)</span>
<span class="fc" id="L193">            TRACE -&gt; ahcClient.prepareTrace(path)</span>
<span class="fc" id="L194">            OPTIONS -&gt; ahcClient.prepareOptions(path)</span>
<span class="fc" id="L195">            PATCH -&gt; ahcClient.preparePatch(path)</span>
        }

<span class="fc" id="L198">        req.setCharset(Charset.defaultCharset()) // TODO Problem if encoding is set?</span>

<span class="fc" id="L200">        parts.forEach { part -&gt; req.addBodyPart(part) }</span>

<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (contentType != null)</span>
<span class="fc" id="L203">            req.addHeader(&quot;Content-Type&quot;, contentType)</span>

<span class="fc" id="L205">        authorization =</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if (settings.user != null)</span>
<span class="fc" id="L207">                base64encoder.encodeToString(&quot;${settings.user}:${settings.password}&quot;</span>
<span class="fc" id="L208">                    .toByteArray(UTF_8))</span>
            else
<span class="fc" id="L210">                null</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (authorization != null)</span>
<span class="fc" id="L212">            req.addHeader(&quot;Authorization&quot;, &quot;Basic $authorization&quot;)</span>

<span class="fc" id="L214">        val info = &quot;&quot;&quot;</span>
<span class="fc" id="L215">            REQUEST METHOD:     $method</span>
<span class="fc" id="L216">            REQUEST PATH:       $path</span>
<span class="fc" id="L217">            CLIENT SETTINGS:    $settings</span>
<span class="fc" id="L218">            CONTENT TYPE:       $contentType</span>
<span class="fc" id="L219">            SSL:                $ssl</span>
<span class="fc" id="L220">        &quot;&quot;&quot;.trimIndent()</span>
<span class="fc" id="L221">        log.info { &quot;Request Created: $info&quot; }</span>

<span class="fc" id="L223">        return req</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>