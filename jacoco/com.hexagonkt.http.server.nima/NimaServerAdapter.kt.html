<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NimaServerAdapter.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">site</a> &gt; <a href="index.source.html" class="el_package">com.hexagonkt.http.server.nima</a> &gt; <span class="el_source">NimaServerAdapter.kt</span></div><h1>NimaServerAdapter.kt</h1><pre class="source lang-java linenums">package com.hexagonkt.http.server.nima

import com.hexagonkt.core.fieldsMapOf
import com.hexagonkt.core.security.loadKeyStore
import com.hexagonkt.core.toText
import com.hexagonkt.http.SslSettings
import com.hexagonkt.http.bodyToBytes
import com.hexagonkt.http.handlers.HttpHandler
import com.hexagonkt.http.model.HttpProtocol
import com.hexagonkt.http.model.HttpProtocol.*
import com.hexagonkt.http.model.HttpResponse
import com.hexagonkt.http.model.HttpResponsePort
import com.hexagonkt.http.server.HttpServer
import com.hexagonkt.http.server.HttpServerFeature
import com.hexagonkt.http.server.HttpServerFeature.ZIP
import com.hexagonkt.http.server.HttpServerPort
import io.helidon.common.http.Http.*
import io.helidon.common.http.HttpMediaType
import io.helidon.common.http.SetCookie
import io.helidon.nima.webserver.WebServer
import io.helidon.nima.webserver.http.ServerResponse
import java.security.SecureRandom
import java.time.Duration
import javax.net.ssl.KeyManagerFactory
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLParameters
import javax.net.ssl.TrustManagerFactory

/**
 * Implements [HttpServerPort] using Helidon Nima.
 */
<span class="fc" id="L32">class NimaServerAdapter : HttpServerPort {</span>

    private companion object {
        const val START_ERROR_MESSAGE = &quot;Nima server not started correctly&quot;
    }

    private var nimaServer: WebServer? = null

    override fun runtimePort(): Int {
<span class="pc bpc" id="L41" title="1 of 2 branches missed.">        return nimaServer?.port() ?: error(START_ERROR_MESSAGE)</span>
    }

    override fun started() =
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">        nimaServer?.isRunning ?: false</span>

    override fun startUp(server: HttpServer) {
<span class="fc" id="L48">        val settings = server.settings</span>
<span class="fc" id="L49">        val sslSettings = settings.sslSettings</span>

<span class="fc" id="L51">        val handlers: Map&lt;Method, HttpHandler&gt; =</span>
<span class="fc" id="L52">            server.handler.addPrefix(settings.contextPath)</span>
<span class="fc" id="L53">                .byMethod()</span>
<span class="fc" id="L54">                .mapKeys { Method.create(it.key.toString()) }</span>

<span class="fc" id="L56">        val serverBuilder = WebServer</span>
<span class="fc" id="L57">            .builder()</span>
<span class="fc" id="L58">            .host(settings.bindAddress.hostName)</span>
<span class="fc" id="L59">            .port(settings.bindPort)</span>
<span class="fc" id="L60">            .routing {</span>
<span class="fc" id="L61">                it.any({ nimaRequest, nimaResponse -&gt;</span>
<span class="fc" id="L62">                    val method = nimaRequest.prologue().method()</span>
<span class="fc" id="L63">                    val request = NimaRequestAdapter(method, nimaRequest)</span>
<span class="pc bpc" id="L64" title="3 of 6 branches missed.">                    val response = handlers[method]?.process(request)?.response ?: HttpResponse()</span>
<span class="fc" id="L65">                    setResponse(response, nimaResponse)</span>
<span class="fc" id="L66">                })</span>
<span class="fc" id="L67">            }</span>

<span class="fc bfc" id="L69" title="All 2 branches covered.">        if (sslSettings != null)</span>
<span class="fc" id="L70">            serverBuilder.tls {</span>
<span class="fc" id="L71">                val sslClientAuth = sslSettings.clientAuth</span>
<span class="fc" id="L72">                it</span>
<span class="fc" id="L73">                    .sslParameters(SSLParameters().apply { needClientAuth = sslClientAuth })</span>
<span class="fc" id="L74">                    .sslContext(sslContext(sslSettings))</span>
<span class="fc" id="L75">            }</span>

<span class="fc" id="L77">        nimaServer = serverBuilder.build()</span>

<span class="pc bpc" id="L79" title="2 of 4 branches missed.">        nimaServer?.start() ?: error(START_ERROR_MESSAGE)</span>
<span class="fc" id="L80">    }</span>

    override fun shutDown() {
<span class="pc bpc" id="L83" title="2 of 4 branches missed.">        nimaServer?.stop() ?: error(START_ERROR_MESSAGE)</span>
<span class="fc" id="L84">    }</span>

    override fun supportedProtocols(): Set&lt;HttpProtocol&gt; =
<span class="fc" id="L87">        setOf(HTTP, HTTPS, HTTP2)</span>

    override fun supportedFeatures(): Set&lt;HttpServerFeature&gt; =
<span class="fc" id="L90">        setOf(ZIP)</span>

    override fun options(): Map&lt;String, *&gt; =
<span class="fc" id="L93">        fieldsMapOf&lt;NimaServerAdapter&gt;()</span>

    private fun setResponse(response: HttpResponsePort, nimaResponse: ServerResponse) {
<span class="fc" id="L96">        try {</span>
<span class="fc" id="L97">            nimaResponse.status(Status.create(response.status.code))</span>

<span class="fc" id="L99">            response.headers.values.forEach {</span>
<span class="fc" id="L100">                nimaResponse.header(Header.create(Header.create(it.name), it.strings()))</span>
<span class="fc" id="L101">            }</span>

<span class="fc" id="L103">            val headers = nimaResponse.headers()</span>
<span class="fc" id="L104">            response.cookies.forEach {</span>
<span class="fc" id="L105">                val cookie = SetCookie</span>
<span class="fc" id="L106">                    .builder(it.name, it.value)</span>
<span class="fc" id="L107">                    .maxAge(Duration.ofSeconds(it.maxAge))</span>
<span class="fc" id="L108">                    .path(it.path)</span>
<span class="fc" id="L109">                    .httpOnly(it.httpOnly)</span>
<span class="fc" id="L110">                    .secure(it.secure)</span>

<span class="pc bpc" id="L112" title="1 of 2 branches missed.">                if (it.expires != null)</span>
<span class="nc" id="L113">                    cookie.expires(it.expires)</span>

<span class="fc bfc" id="L115" title="All 2 branches covered.">                if (it.deleted)</span>
<span class="fc" id="L116">                    headers.clearCookie(it.name)</span>
                else
<span class="fc" id="L118">                    headers.addCookie(cookie.build())</span>
<span class="fc" id="L119">            }</span>

<span class="fc bfc" id="L121" title="All 2 branches covered.">            response.contentType?.let { ct -&gt; headers.contentType(HttpMediaType.create(ct.text)) }</span>

<span class="fc" id="L123">            nimaResponse.send(bodyToBytes(response.body))</span>
        }
<span class="fc" id="L125">        catch (e: Exception) {</span>
<span class="fc" id="L126">            nimaResponse.status(Status.INTERNAL_SERVER_ERROR_500)</span>
<span class="fc" id="L127">            nimaResponse.send(bodyToBytes(e.toText()))</span>
        }
<span class="fc" id="L129">    }</span>

    private fun sslContext(sslSettings: SslSettings): SSLContext {
<span class="fc" id="L132">        val keyManager = createKeyManagerFactory(sslSettings)</span>
<span class="fc" id="L133">        val trustManager = createTrustManagerFactory(sslSettings)</span>

<span class="fc" id="L135">        val eng = SSLContext.getDefault().createSSLEngine()</span>
<span class="fc" id="L136">        eng.needClientAuth = sslSettings.clientAuth</span>
<span class="fc" id="L137">        val context = SSLContext.getInstance(&quot;TLSv1.3&quot;)</span>
<span class="fc" id="L138">        context.init(</span>
<span class="fc" id="L139">            keyManager.keyManagers,</span>
<span class="pc bpc" id="L140" title="1 of 4 branches missed.">            trustManager?.trustManagers ?: emptyArray(),</span>
<span class="fc" id="L141">            SecureRandom.getInstanceStrong()</span>
        )
<span class="fc" id="L143">        return context</span>
    }

    private fun createTrustManagerFactory(sslSettings: SslSettings): TrustManagerFactory? {
<span class="fc bfc" id="L147" title="All 2 branches covered.">        val trustStoreUrl = sslSettings.trustStore ?: return null</span>

<span class="fc" id="L149">        val trustStorePassword = sslSettings.trustStorePassword</span>
<span class="fc" id="L150">        val trustStore = loadKeyStore(trustStoreUrl, trustStorePassword)</span>
<span class="fc" id="L151">        val trustAlgorithm = TrustManagerFactory.getDefaultAlgorithm()</span>
<span class="fc" id="L152">        val trustManager = TrustManagerFactory.getInstance(trustAlgorithm)</span>

<span class="fc" id="L154">        trustManager.init(trustStore)</span>
<span class="fc" id="L155">        return trustManager</span>
    }

    private fun createKeyManagerFactory(sslSettings: SslSettings): KeyManagerFactory {
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        val keyStoreUrl = sslSettings.keyStore ?: error(&quot;&quot;)</span>
<span class="fc" id="L160">        val keyStorePassword = sslSettings.keyStorePassword</span>
<span class="fc" id="L161">        val keyStore = loadKeyStore(keyStoreUrl, keyStorePassword)</span>
<span class="fc" id="L162">        val keyManager = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())</span>
<span class="fc" id="L163">        keyManager.init(keyStore, keyStorePassword.toCharArray())</span>
<span class="fc" id="L164">        return keyManager</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>