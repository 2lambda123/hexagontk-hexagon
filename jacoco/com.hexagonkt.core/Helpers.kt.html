<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Helpers.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">site</a> &gt; <a href="index.source.html" class="el_package">com.hexagonkt.core</a> &gt; <span class="el_source">Helpers.kt</span></div><h1>Helpers.kt</h1><pre class="source lang-java linenums">package com.hexagonkt.core

import com.hexagonkt.core.logging.Logger
import java.io.BufferedReader
import java.io.File
import java.io.InputStreamReader
import java.net.InetAddress
import java.net.ServerSocket
import java.net.Socket
import java.util.*
import java.util.concurrent.TimeUnit.SECONDS
import kotlin.reflect.KClass
import kotlin.reflect.KProperty1

/**
 *  Disable heavy and optional checks in runtime. This flag can be enabled to get a small
 *  performance boost. Do *NOT* do this on development (it could mask problems) and enable it on
 *  production only if you have tested your application extensively.
 *
 *  It's initial value is taken from the `DISABLE_CHECKS` flag. See [Jvm.systemFlag] for details on
 *  how flags are checked on a JVM.
 *
 *  This variable can be changed on code to affect only certain parts of the code, however this is
 *  not advised and should be done carefully.
 */
<span class="fc" id="L26">var disableChecks: Boolean = Jvm.systemFlag(&quot;DISABLE_CHECKS&quot;)</span>

<span class="fc" id="L28">private val logger: Logger by lazy { Logger(&quot;com.hexagonkt.core.Helpers&quot;) }</span>

/**
 * Print receiver to stdout. Convenient utility to debug variables quickly.
 *
 * @receiver Reference to the object to print. Can be `null`.
 * @param prefix String to print before the actual object information. Empty string by default.
 * @return Receiver's reference. Returned to allow method call chaining.
 */
<span class="fc" id="L37">fun &lt;T&gt; T.println(prefix: String = &quot;&quot;): T =</span>
<span class="fc" id="L38">    apply { kotlin.io.println(&quot;$prefix$this&quot;) }</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @param locale .
 * @return .
 */
<span class="nc" id="L46">inline fun &lt;reified T : ResourceBundle&gt; resourceBundle(</span>
<span class="nc" id="L47">    locale: Locale = Locale.getDefault()): ResourceBundle =</span>
<span class="nc" id="L48">        resourceBundle(T::class, locale)</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @param type .
 * @param locale .
 * @return .
 */
<span class="nc" id="L57">fun &lt;T : ResourceBundle&gt; resourceBundle(</span>
<span class="nc" id="L58">    type: KClass&lt;T&gt;, locale: Locale = Locale.getDefault()): ResourceBundle =</span>
<span class="fc" id="L59">        ResourceBundle.getBundle(type.java.name, locale)</span>

// NETWORK /////////////////////////////////////////////////////////////////////////////////////////
/** Internet address used to bind services to all local network interfaces. */
<span class="fc" id="L63">val allInterfaces: InetAddress = inetAddress(0, 0, 0, 0)</span>

/**
 * Syntactic sugar to create an Internet address.
 *
 * @param bytes Bytes used in the address.
 * @return The Internet address corresponding with the supplied bytes.
 */
fun inetAddress(vararg bytes: Byte): InetAddress =
<span class="fc" id="L72">    InetAddress.getByAddress(bytes)</span>

/**
 * Return a random free port (not used by any other local process).
 *
 * @return Random free port number.
 */
fun freePort(): Int =
<span class="pc" id="L80">    ServerSocket(0).use { it.localPort }</span>

/**
 * Check if a port is already opened.
 *
 * @param port Port number to check.
 * @return True if the port is open, false otherwise.
 */
fun isPortOpened(port: Int): Boolean =
<span class="fc" id="L89">    try {</span>
<span class="pc" id="L90">        Socket(&quot;localhost&quot;, port).use { it.isConnected }</span>
    }
<span class="fc" id="L92">    catch (e: Exception) {</span>
<span class="fc" id="L93">        logger.debug { &quot;Checked port: $port is already open&quot; }</span>
<span class="fc" id="L94">        false</span>
<span class="fc" id="L95">    }</span>

// PROCESSES ///////////////////////////////////////////////////////////////////////////////////////
/**
 * Execute a lambda until no exception is thrown or a number of times is reached.
 *
 * @param times Number of times to try to execute the callback. Must be greater than 0.
 * @param delay Milliseconds to wait to next execution if there was an error. Must be 0 or greater.
 * @param block Code to be executed.
 * @return Callback's result if succeed.
 * @throws [MultipleException] if the callback didn't succeed in the given times.
 */
fun &lt;T&gt; retry(times: Int, delay: Long, block: () -&gt; T): T {
<span class="fc bfc" id="L108" title="All 4 branches covered.">    require(times &gt; 0)</span>
<span class="fc bfc" id="L109" title="All 4 branches covered.">    require(delay &gt;= 0)</span>

<span class="fc" id="L111">    val exceptions = mutableListOf&lt;Exception&gt;()</span>
<span class="pc bpc" id="L112" title="1 of 4 branches missed.">    for (ii in 1 .. times) {</span>
<span class="fc" id="L113">        try {</span>
<span class="fc" id="L114">            return block()</span>
        }
<span class="fc" id="L116">        catch (e: Exception) {</span>
<span class="fc" id="L117">            exceptions.add(e)</span>
<span class="fc" id="L118">            Thread.sleep(delay)</span>
        }
    }

<span class="fc" id="L122">    throw MultipleException(&quot;Error retrying $times times ($delay ms)&quot;, exceptions)</span>
}

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * TODO Assure JVM closes properly after process execution (dispose process resources, etc.)
 */
<span class="nc" id="L130">fun List&lt;String&gt;.exec(</span>
<span class="nc" id="L131">    workingDirectory: File = File(System.getProperty(&quot;user.dir&quot;)),</span>
<span class="nc" id="L132">    timeout: Long = Long.MAX_VALUE,</span>
<span class="nc" id="L133">    fail: Boolean = false,</span>
): String {

<span class="fc bfc" id="L136" title="All 4 branches covered.">    val command = filter { it.isNotBlank() }.toTypedArray()</span>

<span class="fc bfc" id="L138" title="All 6 branches covered.">    require(command.isNotEmpty()) { &quot;Command is empty&quot; }</span>
<span class="fc bfc" id="L139" title="All 4 branches covered.">    require(timeout &gt; 0) { &quot;Process timeout should be greater than zero: $timeout&quot; }</span>

<span class="fc" id="L141">    val process = ProcessBuilder(*command).directory(workingDirectory).start()</span>

<span class="fc bfc" id="L143" title="All 2 branches covered.">    if (!process.waitFor(timeout, SECONDS)) {</span>
<span class="fc" id="L144">        process.destroy()</span>
<span class="fc" id="L145">        error(&quot;Command timed out: $this&quot;)</span>
    }

<span class="fc" id="L148">    val exitValue = process.exitValue()</span>
<span class="fc" id="L149">    val output = BufferedReader(InputStreamReader(process.inputStream)).readText()</span>

<span class="pc bpc" id="L151" title="1 of 4 branches missed.">    if (fail &amp;&amp; exitValue != 0)</span>
<span class="fc" id="L152">        throw CodedException(exitValue, output)</span>

<span class="fc" id="L154">    return output</span>
}

/**
 * TODO Add use case and example in documentation.
 * TODO Support multiple words parameters by processing &quot; and '
 *
 * Run the receiver's text as a process in the host operating system. The command can have multiple
 * lines and may or may not contain the shell continuation string (` \\n`).
 *
 * @receiver String holding the command to be executed.
 * @param workingDirectory Directory on which the process will be executed. Defaults to current
 *  directory.
 * @param timeout Maximum number of seconds allowed for process execution. Defaults to the maximum
 *  long value. It must be greater than zero.
 * @param fail If true Raise an exception if the result code is different than zero. The default
 *  value is `false`.
 * @throws CodedException Thrown if the process return an error code (the actual code is passed
 *  inside [CodedException.code] and the command output is set at [CodedException.message].
 * @throws IllegalStateException If the command doesn't end within the allowed time or the command
 *  string is blank, an exception will be thrown.
 * @return The output of the command.
 */
<span class="fc" id="L177">fun String.exec(</span>
<span class="fc" id="L178">    workingDirectory: File = File(System.getProperty(&quot;user.dir&quot;)),</span>
<span class="fc" id="L179">    timeout: Long = Long.MAX_VALUE,</span>
<span class="fc" id="L180">    fail: Boolean = false,</span>
): String =
<span class="fc" id="L182">    replace(&quot;&quot;&quot;(\s+\\\s*)?\n&quot;&quot;&quot;.toRegex(), &quot;&quot;)</span>
<span class="fc" id="L183">        .split(&quot; &quot;)</span>
<span class="fc" id="L184">        .map { it.trim() }</span>
<span class="fc" id="L185">        .toList()</span>
<span class="fc" id="L186">        .exec(workingDirectory, timeout, fail)</span>

// ERROR HANDLING //////////////////////////////////////////////////////////////////////////////////
/** Syntax sugar to throw errors. */
val fail: Nothing
<span class="fc" id="L191">    get() = error(&quot;Invalid state&quot;)</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 */
<span class="nc" id="L196">fun check(message: String = &quot;Multiple exceptions&quot;, vararg blocks: () -&gt; Unit) {</span>
<span class="fc" id="L197">    val exceptions: List&lt;Exception&gt; = blocks.mapNotNull {</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        try {</span>
<span class="fc" id="L199">            it()</span>
<span class="fc" id="L200">            null</span>
        }
<span class="fc" id="L202">        catch(e: Exception) {</span>
<span class="fc" id="L203">            e</span>
        }
    }

<span class="fc bfc" id="L207" title="All 4 branches covered.">    if (exceptions.isNotEmpty())</span>
<span class="fc" id="L208">        throw MultipleException(message, exceptions)</span>
<span class="fc" id="L209">}</span>

/**
 * Return the stack trace array of the frames that starts with the given prefix.
 *
 * @receiver Throwable which stack trace will be filtered.
 * @param prefix Prefix used to filter stack trace elements (applied to class names).
 * @return Array with the frames of the throwable whose classes start with the given prefix.
 */
fun Throwable.filterStackTrace(prefix: String): Array&lt;out StackTraceElement&gt; =
<span class="fc bfc" id="L219" title="All 4 branches covered.">    if (prefix.isEmpty())</span>
<span class="fc" id="L220">        this.stackTrace</span>
    else
<span class="fc bfc" id="L222" title="All 2 branches covered.">        this.stackTrace.filter { it.className.startsWith(prefix) }.toTypedArray()</span>

/**
 * Return this throwable as a text.
 *
 * @receiver Throwable to be printed to a string.
 * @param prefix Optional prefix to filter stack trace elements.
 * @return The filtered (if filter is provided) Throwable as a string.
 */
<span class="fc" id="L231">fun Throwable.toText(prefix: String = &quot;&quot;): String =</span>
<span class="fc" id="L232">    &quot;${this.javaClass.name}: ${this.message}&quot; +</span>
<span class="fc" id="L233">        this.filterStackTrace(prefix).joinToString(eol, eol) { &quot;\tat $it&quot; } +</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (this.cause == null)</span>
<span class="fc" id="L235">            &quot;&quot;</span>
        else
<span class="fc" id="L237">            &quot;${eol}Caused by: &quot; + (this.cause as Throwable).toText(prefix)</span>

// COLLECTIONS /////////////////////////////////////////////////////////////////////////////////////
/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @param count .
 * @return .
 */
<span class="fc" id="L247">fun &lt;Z&gt; Collection&lt;Z&gt;.ensureSize(count: IntRange): Collection&lt;Z&gt; = this.apply {</span>
<span class="fc bfc" id="L248" title="All 6 branches covered.">    if (size !in count) error(&quot;$size items while expecting only $count element&quot;)</span>
<span class="fc" id="L249">}</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @param keys .
 * @return .
 */
@Suppress(&quot;UNCHECKED_CAST&quot;)
inline fun &lt;reified T : Any&gt; Map&lt;*, *&gt;.keys(vararg keys: Any): T? {

    val mappedKeys = keys.map {
        when (it) {
            is KProperty1&lt;*, *&gt; -&gt; it.name
            else -&gt; it
        }
    }

    return mappedKeys
        .dropLast(1)
        .fold(this) { result, element -&gt;
            val r = result as Map&lt;Any, Any&gt;
            when (val value = r[element]) {
                is Map&lt;*, *&gt; -&gt; value
                is List&lt;*&gt; -&gt; value.mapIndexed { ii, item -&gt; ii to item }.toMap()
                else -&gt; emptyMap&lt;Any, Any&gt;()
            }
        }[mappedKeys.last()] as? T
}

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @param keys .
 * @return .
 */
inline operator fun &lt;reified T : Any&gt; Map&lt;*, *&gt;.invoke(vararg keys: Any): T? =
    keys(*keys)

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @param name .
 * @return .
 */
inline fun &lt;reified T : Any&gt; Map&lt;*, *&gt;.requireKeys(vararg name: Any): T =
    this.keys(*name) ?: error(&quot;$name required key not found&quot;)

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @param fields .
 * @return .
 */
fun &lt;T : Any&gt; fieldsMapOf(vararg fields: Pair&lt;KProperty1&lt;T, *&gt;, *&gt;): Map&lt;String, *&gt; =
<span class="fc" id="L307">    fields.associate { it.first.name to it.second }</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @param name .
 * @return .
 */
fun &lt;K, V&gt; Map&lt;K, V&gt;.require(name: K): V =
<span class="fc bfc" id="L317" title="All 2 branches covered.">    this[name] ?: error(&quot;$name required key not found&quot;)</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @return .
 */
fun &lt;K, V&gt; Map&lt;K, V?&gt;.filterEmpty(): Map&lt;K, V&gt; =
<span class="pc bpc" id="L326" title="1 of 4 branches missed.">    this.filterValues(::notEmpty).mapValues { (_, v) -&gt; v ?: fail }</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @return .
 */
fun &lt;V&gt; List&lt;V?&gt;.filterEmpty(): List&lt;V&gt; =
<span class="pc bpc" id="L335" title="1 of 4 branches missed.">    this.filter(::notEmpty).map { it ?: fail }</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @return .
 */
fun Map&lt;*, *&gt;.filterEmptyRecursive(): Map&lt;*, *&gt; =
<span class="fc" id="L344">    mapValues { (_, v) -&gt;</span>
<span class="fc" id="L345">        when (v) {</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">            is List&lt;*&gt; -&gt; v.filterEmptyRecursive()</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">            is Map&lt;*, *&gt; -&gt; v.filterEmptyRecursive()</span>
<span class="fc" id="L348">            else -&gt; v</span>
        }
    }
<span class="fc" id="L351">    .filterEmpty()</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @return .
 */
fun List&lt;*&gt;.filterEmptyRecursive(): List&lt;*&gt; =
<span class="fc" id="L360">    map {</span>
<span class="fc" id="L361">        when (it) {</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            is List&lt;*&gt; -&gt; it.filterEmptyRecursive()</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            is Map&lt;*, *&gt; -&gt; it.filterEmptyRecursive()</span>
<span class="fc" id="L364">            else -&gt; it</span>
        }
    }
<span class="fc" id="L367">    .filterEmpty()</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @param value .
 * @return .
 */
fun &lt;V&gt; notEmpty(value: V?): Boolean {
<span class="fc" id="L376">    return when (value) {</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">        null -&gt; false</span>
<span class="fc bfc" id="L378" title="All 4 branches covered.">        is List&lt;*&gt; -&gt; value.isNotEmpty()</span>
<span class="fc bfc" id="L379" title="All 4 branches covered.">        is Map&lt;*, *&gt; -&gt; value.isNotEmpty()</span>
<span class="fc" id="L380">        else -&gt; true</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>