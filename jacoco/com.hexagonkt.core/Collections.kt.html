<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Collections.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">site</a> &gt; <a href="index.source.html" class="el_package">com.hexagonkt.core</a> &gt; <span class="el_source">Collections.kt</span></div><h1>Collections.kt</h1><pre class="source lang-java linenums">package com.hexagonkt.core

import kotlin.reflect.KProperty1

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @param count .
 * @return .
 */
<span class="fc" id="L12">fun &lt;Z&gt; Collection&lt;Z&gt;.ensureSize(count: IntRange): Collection&lt;Z&gt; = this.apply {</span>
<span class="fc bfc" id="L13" title="All 6 branches covered.">    if (size !in count) error(&quot;$size items while expecting only $count element&quot;)</span>
<span class="fc" id="L14">}</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @param keys .
 * @return .
 */
@Suppress(&quot;UNCHECKED_CAST&quot;)
inline fun &lt;reified T : Any&gt; Map&lt;*, *&gt;.keys(vararg keys: Any): T? {

    val mappedKeys = keys.map {
        when (it) {
            is KProperty1&lt;*, *&gt; -&gt; it.name
            else -&gt; it
        }
    }

    return mappedKeys
        .dropLast(1)
        .fold(this) { result, element -&gt;
            val r = result as Map&lt;Any, Any&gt;
            when (val value = r[element]) {
                is Map&lt;*, *&gt; -&gt; value
                is List&lt;*&gt; -&gt; value.mapIndexed { ii, item -&gt; ii to item }.toMap()
                else -&gt; emptyMap&lt;Any, Any&gt;()
            }
        }[mappedKeys.last()] as? T
}

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @param keys .
 * @return .
 */
inline operator fun &lt;reified T : Any&gt; Map&lt;*, *&gt;.invoke(vararg keys: Any): T? =
    keys(*keys)

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @param name .
 * @return .
 */
inline fun &lt;reified T : Any&gt; Map&lt;*, *&gt;.requireKeys(vararg name: Any): T =
    this.keys(*name) ?: error(&quot;$name required key not found&quot;)

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @param fields .
 * @return .
 */
fun &lt;T : Any&gt; fieldsMapOf(vararg fields: Pair&lt;KProperty1&lt;T, *&gt;, *&gt;): Map&lt;String, *&gt; =
<span class="fc" id="L72">    fields.associate { it.first.name to it.second }</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @param fields .
 * @return .
 */
fun &lt;T : Any&gt; fieldsMapOfNotNull(vararg fields: Pair&lt;KProperty1&lt;T, *&gt;, *&gt;): Map&lt;String, *&gt; =
<span class="fc bfc" id="L81" title="All 4 branches covered.">    fieldsMapOf(*fields).filterValues { it != null }</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @param name .
 * @return .
 */
fun &lt;K, V&gt; Map&lt;K, V&gt;.require(name: K): V =
<span class="fc bfc" id="L91" title="All 2 branches covered.">    this[name] ?: error(&quot;$name required key not found&quot;)</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @return .
 */
fun &lt;K, V&gt; Map&lt;K, V?&gt;.filterEmpty(): Map&lt;K, V&gt; =
<span class="pc bpc" id="L100" title="1 of 4 branches missed.">    this.filterValues(::notEmpty).mapValues { (_, v) -&gt; v ?: fail }</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @return .
 */
fun &lt;V&gt; List&lt;V?&gt;.filterEmpty(): List&lt;V&gt; =
<span class="pc bpc" id="L109" title="1 of 4 branches missed.">    this.filter(::notEmpty).map { it ?: fail }</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @return .
 */
fun Map&lt;*, *&gt;.filterEmptyRecursive(): Map&lt;*, *&gt; =
<span class="fc" id="L118">    mapValues { (_, v) -&gt;</span>
<span class="fc" id="L119">        when (v) {</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">            is List&lt;*&gt; -&gt; v.filterEmptyRecursive()</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            is Map&lt;*, *&gt; -&gt; v.filterEmptyRecursive()</span>
<span class="fc" id="L122">            else -&gt; v</span>
        }
    }
<span class="fc" id="L125">        .filterEmpty()</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @receiver .
 * @return .
 */
fun List&lt;*&gt;.filterEmptyRecursive(): List&lt;*&gt; =
<span class="fc" id="L134">    map {</span>
<span class="fc" id="L135">        when (it) {</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">            is List&lt;*&gt; -&gt; it.filterEmptyRecursive()</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            is Map&lt;*, *&gt; -&gt; it.filterEmptyRecursive()</span>
<span class="fc" id="L138">            else -&gt; it</span>
        }
    }
<span class="fc" id="L141">        .filterEmpty()</span>

/**
 * [TODO](https://github.com/hexagonkt/hexagon/issues/271).
 *
 * @param value .
 * @return .
 */
fun &lt;V&gt; notEmpty(value: V?): Boolean {
<span class="fc" id="L150">    return when (value) {</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        null -&gt; false</span>
<span class="fc bfc" id="L152" title="All 4 branches covered.">        is List&lt;*&gt; -&gt; value.isNotEmpty()</span>
<span class="fc bfc" id="L153" title="All 4 branches covered.">        is Map&lt;*, *&gt; -&gt; value.isNotEmpty()</span>
<span class="fc" id="L154">        else -&gt; true</span>
    }
}

// TODO TEST FROM HERE

inline fun &lt;reified T : Any&gt; Map&lt;*, *&gt;.getKey(key: KProperty1&lt;*, *&gt;): T? =
    this[key.name] as? T

fun Map&lt;*, *&gt;.getInt(key: KProperty1&lt;*, *&gt;): Int? =
<span class="fc" id="L164">    getKey(key)</span>

fun Map&lt;*, *&gt;.getLong(key: KProperty1&lt;*, *&gt;): Long? =
<span class="fc" id="L167">    getKey(key)</span>

fun Map&lt;*, *&gt;.getFloat(key: KProperty1&lt;*, *&gt;): Float? =
<span class="fc" id="L170">    getKey(key)</span>

fun Map&lt;*, *&gt;.getDouble(key: KProperty1&lt;*, *&gt;): Double? =
<span class="fc" id="L173">    getKey(key)</span>

fun Map&lt;*, *&gt;.getBoolean(key: KProperty1&lt;*, *&gt;): Boolean? =
<span class="fc" id="L176">    getKey(key)</span>

fun Map&lt;*, *&gt;.getString(key: KProperty1&lt;*, *&gt;): String? =
<span class="fc" id="L179">    getKey(key)</span>

fun Map&lt;*, *&gt;.getList(key: KProperty1&lt;*, *&gt;): List&lt;*&gt;? =
<span class="fc" id="L182">    getKey(key)</span>

fun Map&lt;*, *&gt;.getMap(key: KProperty1&lt;*, *&gt;): Map&lt;String, *&gt;? =
<span class="fc" id="L185">    getKey(key)</span>

fun Map&lt;*, *&gt;.getInts(key: KProperty1&lt;*, *&gt;): List&lt;Int&gt;? =
<span class="fc" id="L188">    getKey(key)</span>

fun Map&lt;*, *&gt;.getLongs(key: KProperty1&lt;*, *&gt;): List&lt;Long&gt;? =
<span class="fc" id="L191">    getKey(key)</span>

fun Map&lt;*, *&gt;.getFloats(key: KProperty1&lt;*, *&gt;): List&lt;Float&gt;? =
<span class="fc" id="L194">    getKey(key)</span>

fun Map&lt;*, *&gt;.getDoubles(key: KProperty1&lt;*, *&gt;): List&lt;Double&gt;? =
<span class="fc" id="L197">    getKey(key)</span>

fun Map&lt;*, *&gt;.getBooleans(key: KProperty1&lt;*, *&gt;): List&lt;Boolean&gt;? =
<span class="fc" id="L200">    getKey(key)</span>

fun Map&lt;*, *&gt;.getStrings(key: KProperty1&lt;*, *&gt;): List&lt;String&gt;? =
<span class="fc" id="L203">    getKey(key)</span>

fun Map&lt;*, *&gt;.getLists(key: KProperty1&lt;*, *&gt;): List&lt;List&lt;*&gt;&gt;? =
<span class="fc" id="L206">    getKey(key)</span>

fun Map&lt;*, *&gt;.getMaps(key: KProperty1&lt;*, *&gt;): List&lt;Map&lt;String, *&gt;&gt;? =
<span class="fc" id="L209">    getKey(key)</span>

inline fun &lt;reified T : Any&gt; Map&lt;*, *&gt;.requireKey(key: KProperty1&lt;*, *&gt;): T =
    getKey(key) ?: error(&quot;$key key not found, or wrong type (must be ${key::class.qualifiedName})&quot;)

fun Map&lt;*, *&gt;.requireInt(key: KProperty1&lt;*, *&gt;): Int =
<span class="fc" id="L215">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireLong(key: KProperty1&lt;*, *&gt;): Long =
<span class="fc" id="L218">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireFloat(key: KProperty1&lt;*, *&gt;): Float =
<span class="fc" id="L221">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireDouble(key: KProperty1&lt;*, *&gt;): Double =
<span class="fc" id="L224">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireBoolean(key: KProperty1&lt;*, *&gt;): Boolean =
<span class="fc" id="L227">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireString(key: KProperty1&lt;*, *&gt;): String =
<span class="fc" id="L230">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireList(key: KProperty1&lt;*, *&gt;): List&lt;*&gt; =
<span class="fc" id="L233">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireMap(key: KProperty1&lt;*, *&gt;): Map&lt;String, *&gt; =
<span class="fc" id="L236">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireInts(key: KProperty1&lt;*, *&gt;): List&lt;Int&gt; =
<span class="fc" id="L239">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireLongs(key: KProperty1&lt;*, *&gt;): List&lt;Long&gt; =
<span class="fc" id="L242">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireFloats(key: KProperty1&lt;*, *&gt;): List&lt;Float&gt; =
<span class="fc" id="L245">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireDoubles(key: KProperty1&lt;*, *&gt;): List&lt;Double&gt; =
<span class="fc" id="L248">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireBooleans(key: KProperty1&lt;*, *&gt;): List&lt;Boolean&gt; =
<span class="fc" id="L251">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireStrings(key: KProperty1&lt;*, *&gt;): List&lt;String&gt; =
<span class="fc" id="L254">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireLists(key: KProperty1&lt;*, *&gt;): List&lt;List&lt;*&gt;&gt; =
<span class="fc" id="L257">    requireKey(key)</span>

fun Map&lt;*, *&gt;.requireMaps(key: KProperty1&lt;*, *&gt;): List&lt;Map&lt;String, *&gt;&gt; =
<span class="fc" id="L260">    requireKey(key)</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>