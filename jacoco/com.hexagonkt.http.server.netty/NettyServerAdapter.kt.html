<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NettyServerAdapter.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">site</a> &gt; <a href="index.source.html" class="el_package">com.hexagonkt.http.server.netty</a> &gt; <span class="el_source">NettyServerAdapter.kt</span></div><h1>NettyServerAdapter.kt</h1><pre class="source lang-java linenums">package com.hexagonkt.http.server.netty

import com.hexagonkt.core.Jvm
import com.hexagonkt.core.fieldsMapOf
import com.hexagonkt.core.security.loadKeyStore
import com.hexagonkt.http.SslSettings
import com.hexagonkt.http.model.HttpProtocol
import com.hexagonkt.http.model.HttpProtocol.*
import com.hexagonkt.http.server.HttpServer
import com.hexagonkt.http.server.HttpServerFeature
import com.hexagonkt.http.server.HttpServerFeature.ASYNC
import com.hexagonkt.http.server.HttpServerFeature.ZIP
import com.hexagonkt.http.server.HttpServerPort
import com.hexagonkt.http.server.HttpServerSettings
import com.hexagonkt.http.server.handlers.PathHandler
import com.hexagonkt.http.server.handlers.path
import io.netty.bootstrap.ServerBootstrap
import io.netty.channel.Channel
import io.netty.channel.ChannelInitializer
import io.netty.channel.ChannelOption
import io.netty.channel.nio.NioEventLoopGroup
import io.netty.channel.socket.SocketChannel
import io.netty.channel.socket.nio.NioServerSocketChannel
import io.netty.handler.codec.http.*
import io.netty.handler.ssl.ClientAuth.OPTIONAL
import io.netty.handler.ssl.ClientAuth.REQUIRE
import io.netty.handler.ssl.SslContext
import io.netty.handler.ssl.SslContextBuilder
import io.netty.handler.stream.ChunkedWriteHandler
import io.netty.util.concurrent.DefaultEventExecutorGroup
import io.netty.util.concurrent.EventExecutorGroup
import java.net.InetSocketAddress
import javax.net.ssl.KeyManagerFactory
import javax.net.ssl.TrustManagerFactory
import kotlin.Int.Companion.MAX_VALUE

/**
 * Implements [HttpServerPort] using Netty [Channel].
 *
 * TODO Add HTTP/2 support: https://www.baeldung.com/netty-http2
 * TODO Add SSE support: https://github.com/marcusyates/netty-sse-example
 */
<span class="pc" id="L43">class NettyServerAdapter(</span>
<span class="pc" id="L44">    private val bossGroupThreads: Int = 1,</span>
<span class="pc" id="L45">    private val workerGroupThreads: Int = 0,</span>
<span class="pc" id="L46">    private val executorThreads: Int = Jvm.cpuCount * 2,</span>
<span class="pc" id="L47">    private val soBacklog: Int = 4 * 1_024,</span>
<span class="pc" id="L48">    private val soReuseAddr: Boolean = true,</span>
<span class="pc" id="L49">    private val soKeepAlive: Boolean = true,</span>
) : HttpServerPort {

    private var nettyChannel: Channel? = null
    private var bossEventLoop: NioEventLoopGroup? = null
    private var workerEventLoop: NioEventLoopGroup? = null

<span class="fc" id="L56">    constructor() : this(</span>
<span class="fc" id="L57">        bossGroupThreads = 1,</span>
<span class="fc" id="L58">        workerGroupThreads = 0,</span>
<span class="fc" id="L59">        executorThreads = Jvm.cpuCount * 2,</span>
<span class="fc" id="L60">        soBacklog = 4 * 1_024,</span>
<span class="fc" id="L61">        soReuseAddr = true,</span>
<span class="fc" id="L62">        soKeepAlive = true,</span>
<span class="fc" id="L63">    )</span>

    override fun runtimePort(): Int =
<span class="pc bpc" id="L66" title="4 of 8 branches missed.">        (nettyChannel?.localAddress() as? InetSocketAddress)?.port</span>
<span class="pc" id="L67">            ?: error(&quot;Error fetching runtime port&quot;)</span>

    override fun started() =
<span class="fc bfc" id="L70" title="All 2 branches covered.">        nettyChannel?.isOpen ?: false</span>

    override fun startUp(server: HttpServer) {
<span class="fc" id="L73">        val bossGroup = NioEventLoopGroup(bossGroupThreads)</span>
<span class="fc" id="L74">        val workerGroup = NioEventLoopGroup(workerGroupThreads)</span>
<span class="fc" id="L75">        val executorGroup =</span>
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">            if (executorThreads &gt; 0) DefaultEventExecutorGroup(executorThreads)</span>
<span class="nc" id="L77">            else null</span>

<span class="fc" id="L79">        try {</span>
<span class="fc" id="L80">            val nettyServer = ServerBootstrap()</span>
<span class="fc" id="L81">            val settings = server.settings</span>
<span class="fc" id="L82">            val sslSettings = settings.sslSettings</span>
<span class="fc" id="L83">            val handlers: Map&lt;HttpMethod, PathHandler&gt; =</span>
<span class="fc" id="L84">                path(settings.contextPath, server.handlers)</span>
<span class="fc" id="L85">                    .byMethod()</span>
<span class="fc" id="L86">                    .mapKeys { HttpMethod.valueOf(it.key.toString()) }</span>

<span class="fc" id="L88">            nettyServer.group(bossGroup, workerGroup)</span>
<span class="fc" id="L89">                .channel(NioServerSocketChannel::class.java)</span>
//                .option(EpollChannelOption.SO_REUSEPORT, true)
<span class="fc" id="L91">                .option(ChannelOption.SO_BACKLOG, soBacklog)</span>
<span class="fc" id="L92">                .option(ChannelOption.SO_REUSEADDR, soReuseAddr)</span>
<span class="fc" id="L93">                .childOption(ChannelOption.SO_KEEPALIVE, soKeepAlive)</span>
<span class="fc" id="L94">                .childOption(ChannelOption.SO_REUSEADDR, soReuseAddr)</span>
<span class="fc" id="L95">                .childHandler(createInitializer(sslSettings, handlers, executorGroup, settings))</span>

<span class="fc" id="L97">            val address = settings.bindAddress</span>
<span class="fc" id="L98">            val port = settings.bindPort</span>
<span class="fc" id="L99">            val future = nettyServer.bind(address, port).sync()</span>

<span class="fc" id="L101">            nettyChannel = future.channel()</span>
<span class="fc" id="L102">            bossEventLoop = bossGroup</span>
<span class="fc" id="L103">            workerEventLoop = workerGroup</span>
        }
<span class="nc" id="L105">        catch (e: Exception) {</span>
<span class="nc" id="L106">            bossGroup.shutdownGracefully()</span>
<span class="nc" id="L107">            workerGroup.shutdownGracefully()</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">            executorGroup?.shutdownGracefully()</span>
        }
<span class="fc" id="L110">    }</span>

    private fun createInitializer(
        sslSettings: SslSettings?,
        handlers: Map&lt;HttpMethod, PathHandler&gt;,
        group: DefaultEventExecutorGroup?,
        settings: HttpServerSettings
    ) =
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (sslSettings == null) {</span>
<span class="fc" id="L119">            HttpChannelInitializer(handlers, group, settings)</span>
        } else {
<span class="fc" id="L121">            val keyManager = createKeyManagerFactory(sslSettings)</span>

<span class="fc" id="L123">            val sslContextBuilder = SslContextBuilder</span>
<span class="fc" id="L124">                .forServer(keyManager)</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">                .clientAuth(if (sslSettings.clientAuth) REQUIRE else OPTIONAL)</span>

<span class="fc" id="L127">            val trustManager = createTrustManagerFactory(sslSettings)</span>

<span class="fc" id="L129">            val sslContext: SslContext =</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">                if (trustManager == null) sslContextBuilder.build()</span>
<span class="fc" id="L131">                else sslContextBuilder.trustManager(trustManager).build()</span>

<span class="fc" id="L133">            HttpsChannelInitializer(handlers, sslContext, sslSettings, group, settings)</span>
<span class="fc" id="L134">        }</span>

    private fun createTrustManagerFactory(sslSettings: SslSettings): TrustManagerFactory? {
<span class="fc bfc" id="L137" title="All 2 branches covered.">        val trustStoreUrl = sslSettings.trustStore ?: return null</span>

<span class="fc" id="L139">        val trustStorePassword = sslSettings.trustStorePassword</span>
<span class="fc" id="L140">        val trustStore = loadKeyStore(trustStoreUrl, trustStorePassword)</span>
<span class="fc" id="L141">        val trustAlgorithm = TrustManagerFactory.getDefaultAlgorithm()</span>
<span class="fc" id="L142">        val trustManager = TrustManagerFactory.getInstance(trustAlgorithm)</span>

<span class="fc" id="L144">        trustManager.init(trustStore)</span>
<span class="fc" id="L145">        return trustManager</span>
    }

    private fun createKeyManagerFactory(sslSettings: SslSettings): KeyManagerFactory {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        val keyStoreUrl = sslSettings.keyStore ?: error(&quot;&quot;)</span>
<span class="fc" id="L150">        val keyStorePassword = sslSettings.keyStorePassword</span>
<span class="fc" id="L151">        val keyStore = loadKeyStore(keyStoreUrl, keyStorePassword)</span>
<span class="fc" id="L152">        val keyManager = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())</span>
<span class="fc" id="L153">        keyManager.init(keyStore, keyStorePassword.toCharArray())</span>
<span class="fc" id="L154">        return keyManager</span>
    }

    override fun shutDown() {
<span class="pc bpc" id="L158" title="2 of 4 branches missed.">        workerEventLoop?.shutdownGracefully()?.sync()</span>
<span class="pc bpc" id="L159" title="2 of 4 branches missed.">        bossEventLoop?.shutdownGracefully()?.sync()</span>

<span class="fc" id="L161">        nettyChannel = null</span>
<span class="fc" id="L162">        bossEventLoop = null</span>
<span class="fc" id="L163">        workerEventLoop = null</span>
<span class="fc" id="L164">    }</span>

    override fun supportedProtocols(): Set&lt;HttpProtocol&gt; =
<span class="fc" id="L167">        setOf(HTTP, HTTPS, HTTP2)</span>

    override fun supportedFeatures(): Set&lt;HttpServerFeature&gt; =
<span class="fc" id="L170">        setOf(ZIP, ASYNC)</span>

    override fun options(): Map&lt;String, *&gt; =
<span class="nc" id="L173">        fieldsMapOf(</span>
<span class="nc" id="L174">            NettyServerAdapter::bossGroupThreads to bossGroupThreads,</span>
<span class="nc" id="L175">            NettyServerAdapter::workerGroupThreads to workerGroupThreads,</span>
<span class="nc" id="L176">            NettyServerAdapter::executorThreads to executorThreads,</span>
<span class="nc" id="L177">            NettyServerAdapter::soBacklog to soBacklog,</span>
<span class="nc" id="L178">            NettyServerAdapter::soKeepAlive to soKeepAlive,</span>
<span class="nc" id="L179">        )</span>

<span class="fc" id="L181">    class HttpChannelInitializer(</span>
<span class="fc" id="L182">        private val handlers: Map&lt;HttpMethod, PathHandler&gt;,</span>
<span class="fc" id="L183">        private val executorGroup: EventExecutorGroup?,</span>
<span class="fc" id="L184">        private val settings: HttpServerSettings,</span>
<span class="fc" id="L185">    ) : ChannelInitializer&lt;SocketChannel&gt;() {</span>

        override fun initChannel(channel: SocketChannel) {
<span class="fc" id="L188">            val pipeline = channel.pipeline()</span>

<span class="fc" id="L190">            pipeline.addLast(HttpServerCodec())</span>
<span class="fc" id="L191">            pipeline.addLast(HttpServerKeepAliveHandler())</span>
<span class="fc" id="L192">            pipeline.addLast(HttpObjectAggregator(MAX_VALUE))</span>
<span class="fc" id="L193">            pipeline.addLast(ChunkedWriteHandler())</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">            if (settings.features.contains(ZIP))</span>
<span class="fc" id="L196">                pipeline.addLast(HttpContentCompressor())</span>

<span class="pc bpc" id="L198" title="1 of 2 branches missed.">            if (executorGroup == null)</span>
<span class="nc" id="L199">                pipeline.addLast(NettyServerHandler(handlers, null))</span>
            else
<span class="fc" id="L201">                pipeline.addLast(executorGroup, NettyServerHandler(handlers, null))</span>
<span class="fc" id="L202">        }</span>
    }

<span class="fc" id="L205">    class HttpsChannelInitializer(</span>
<span class="fc" id="L206">        private val handlers: Map&lt;HttpMethod, PathHandler&gt;,</span>
<span class="fc" id="L207">        private val sslContext: SslContext,</span>
<span class="fc" id="L208">        private val sslSettings: SslSettings,</span>
<span class="fc" id="L209">        private val executorGroup: EventExecutorGroup?,</span>
<span class="fc" id="L210">        private val settings: HttpServerSettings,</span>
<span class="fc" id="L211">    ) : ChannelInitializer&lt;SocketChannel&gt;() {</span>

        override fun initChannel(channel: SocketChannel) {
<span class="fc" id="L214">            val pipeline = channel.pipeline()</span>
<span class="fc" id="L215">            val sslHandler = sslContext.newHandler(channel.alloc())</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">            val handlerSsl = if (sslSettings.clientAuth) sslHandler else null</span>

<span class="fc" id="L218">            pipeline.addLast(sslHandler)</span>
<span class="fc" id="L219">            pipeline.addLast(HttpServerCodec())</span>
<span class="fc" id="L220">            pipeline.addLast(HttpServerKeepAliveHandler())</span>
<span class="fc" id="L221">            pipeline.addLast(HttpObjectAggregator(MAX_VALUE))</span>
<span class="fc" id="L222">            pipeline.addLast(ChunkedWriteHandler())</span>

<span class="pc bpc" id="L224" title="1 of 2 branches missed.">            if (settings.features.contains(ZIP))</span>
<span class="nc" id="L225">                pipeline.addLast(HttpContentCompressor())</span>

<span class="pc bpc" id="L227" title="1 of 2 branches missed.">            if (executorGroup == null)</span>
<span class="nc" id="L228">                pipeline.addLast(NettyServerHandler(handlers, handlerSsl))</span>
            else
<span class="fc" id="L230">                pipeline.addLast(executorGroup, NettyServerHandler(handlers, handlerSsl))</span>
<span class="fc" id="L231">        }</span>
    }
<span class="nc" id="L233">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>