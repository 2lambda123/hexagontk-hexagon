<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JettyClientAdapter.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">site</a> &gt; <a href="index.source.html" class="el_package">com.hexagonkt.http.client.jetty</a> &gt; <span class="el_source">JettyClientAdapter.kt</span></div><h1>JettyClientAdapter.kt</h1><pre class="source lang-java linenums">package com.hexagonkt.http.client.jetty

import com.hexagonkt.core.fail
import com.hexagonkt.core.security.loadKeyStore
import com.hexagonkt.http.bodyToBytes
import com.hexagonkt.http.checkedHeaders
import com.hexagonkt.http.client.HttpClient
import com.hexagonkt.http.client.HttpClientPort
import com.hexagonkt.http.client.HttpClientSettings
import com.hexagonkt.http.client.model.HttpClientRequest
import com.hexagonkt.http.client.model.HttpClientResponse
import com.hexagonkt.http.model.*
import com.hexagonkt.http.model.ws.WsCloseStatus
import com.hexagonkt.http.model.ws.WsSession
import com.hexagonkt.http.parseContentType
import org.eclipse.jetty.client.HttpResponseException
import org.eclipse.jetty.client.api.ContentResponse
import org.eclipse.jetty.client.api.Request
import org.eclipse.jetty.client.api.Response
import org.eclipse.jetty.client.dynamic.HttpClientTransportDynamic
import org.eclipse.jetty.client.util.BytesRequestContent
import org.eclipse.jetty.client.util.MultiPartRequestContent
import org.eclipse.jetty.client.util.StringRequestContent
import org.eclipse.jetty.http.HttpFields
import org.eclipse.jetty.http.HttpFields.EMPTY
import org.eclipse.jetty.http.HttpMethod
import org.eclipse.jetty.io.ClientConnector
import org.eclipse.jetty.websocket.client.WebSocketClient
import java.lang.StringBuilder
import java.net.CookieStore
import java.net.URI
import java.util.concurrent.ExecutionException
import java.util.concurrent.Flow.Publisher
import java.util.concurrent.SubmissionPublisher
import org.eclipse.jetty.client.HttpClient as JettyHttpClient
import org.eclipse.jetty.util.ssl.SslContextFactory.Client as ClientSslContextFactory

/**
 * Client to use other REST services.
 */
<span class="fc" id="L41">class JettyClientAdapter : HttpClientPort {</span>

    private lateinit var jettyClient: JettyHttpClient
    private lateinit var httpClient: HttpClient
    private lateinit var wsClient: WebSocketClient
    private var started: Boolean = false

    override fun startUp(client: HttpClient) {
<span class="fc" id="L49">        val clientConnector = ClientConnector()</span>
<span class="fc" id="L50">        clientConnector.sslContextFactory = sslContext(client.settings)</span>

<span class="fc" id="L52">        jettyClient = JettyHttpClient(HttpClientTransportDynamic(clientConnector))</span>
<span class="fc" id="L53">        httpClient = client</span>

<span class="pc bpc" id="L55" title="1 of 2 branches missed.">        jettyClient.userAgentField = null // Disable default user agent header</span>
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">        jettyClient.start()</span>
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        wsClient = WebSocketClient(jettyClient)</span>
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">        wsClient.start()</span>
<span class="fc" id="L59">        started = true</span>
<span class="fc" id="L60">    }</span>

    override fun shutDown() {
<span class="fc bfc" id="L63" title="All 2 branches covered.">        check(started) { &quot;HTTP client *MUST BE STARTED* before shut-down&quot; }</span>
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">        wsClient.stop()</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">        jettyClient.stop()</span>
<span class="fc" id="L66">        started = false</span>
<span class="fc" id="L67">    }</span>

    override fun started() =
<span class="nc" id="L70">        started</span>

    override fun send(request: HttpClientRequest): HttpClientResponse {
<span class="fc bfc" id="L73" title="All 2 branches covered.">        check(started) { &quot;HTTP client *MUST BE STARTED* before sending requests&quot; }</span>

<span class="fc" id="L75">        val response =</span>
<span class="fc" id="L76">            try {</span>
<span class="pc bpc" id="L77" title="2 of 4 branches missed.">                createJettyRequest(httpClient, jettyClient, request).send()</span>
            }
<span class="fc" id="L79">            catch (e: ExecutionException) {</span>
<span class="fc" id="L80">                val cause = e.cause</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">                if (cause is HttpResponseException) cause.response</span>
<span class="fc" id="L82">                else throw e</span>
            }

<span class="pc bpc" id="L85" title="2 of 4 branches missed.">        return convertJettyResponse(httpClient, jettyClient, response)</span>
    }

    override fun ws(
        path: String,
        onConnect: WsSession.() -&gt; Unit,
        onBinary: WsSession.(data: ByteArray) -&gt; Unit,
        onText: WsSession.(text: String) -&gt; Unit,
        onPing: WsSession.(data: ByteArray) -&gt; Unit,
        onPong: WsSession.(data: ByteArray) -&gt; Unit,
        onClose: WsSession.(status: WsCloseStatus, reason: String) -&gt; Unit,
    ): WsSession {

<span class="fc bfc" id="L98" title="All 2 branches covered.">        check(started) { &quot;HTTP client *MUST BE STARTED* before connecting to WS&quot; }</span>

<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        val baseUrl = httpClient.settings.baseUrl</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">        val scheme = if (baseUrl.protocol.lowercase() == &quot;https&quot;) &quot;wss&quot; else &quot;ws&quot;</span>
<span class="fc" id="L102">        val uri = URI(&quot;$scheme://${baseUrl.host}:${baseUrl.port}${baseUrl.path}$path&quot;)</span>
<span class="fc" id="L103">        val adapter =</span>
<span class="fc" id="L104">            JettyWebSocketAdapter(uri, onConnect, onBinary, onText, onPing, onPong, onClose)</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        val session = wsClient.connect(adapter, uri).get()</span>

<span class="fc" id="L107">        return JettyClientWsSession(uri, session)</span>
    }

    override fun sse(path: String): Publisher&lt;ServerEvent&gt; {
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">        check(started) { &quot;HTTP client *MUST BE STARTED* before sending requests&quot; }</span>

<span class="fc" id="L113">        val clientPublisher = SubmissionPublisher&lt;ServerEvent&gt;()</span>

<span class="pc bpc" id="L115" title="2 of 4 branches missed.">        createJettyRequest(httpClient, jettyClient, HttpClientRequest(path = path))</span>
<span class="fc" id="L116">            .onResponseBegin {</span>
<span class="pc bpc" id="L117" title="3 of 6 branches missed.">                if (it.status !in 200 until 300)</span>
<span class="nc" id="L118">                    error(&quot;Invalid response: ${it.status}&quot;)</span>
<span class="fc" id="L119">            }</span>
<span class="fc" id="L120">            .onResponseContent { _, content -&gt;</span>
<span class="fc" id="L121">                val sb = StringBuilder()</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">                while (content.hasRemaining())</span>
<span class="pc bpc" id="L123" title="2 of 4 branches missed.">                    sb.append(Char(content.get().toInt()))</span>

<span class="fc" id="L125">                val evt = sb</span>
<span class="fc" id="L126">                    .trim()</span>
<span class="fc" id="L127">                    .lines()</span>
<span class="fc" id="L128">                    .map { it.split(&quot;:&quot;) }</span>
<span class="fc" id="L129">                    .associate { it.first().trim().lowercase() to it.last().trim() }</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">                    .let { ServerEvent(it[&quot;event&quot;], it[&quot;data&quot;], it[&quot;id&quot;], it[&quot;retry&quot;]?.toLong()) }</span>

<span class="fc" id="L132">                clientPublisher.submit(evt)</span>
<span class="fc" id="L133">            }</span>
<span class="fc" id="L134">            .send {}</span>

<span class="fc" id="L136">        return clientPublisher</span>
    }

    private fun convertJettyResponse(
        adapterHttpClient: HttpClient, adapterJettyClient: JettyHttpClient, response: Response
    ): HttpClientResponse {

<span class="fc bfc" id="L143" title="All 2 branches covered.">        val bodyString = if (response is ContentResponse) response.contentAsString else &quot;&quot;</span>
<span class="fc" id="L144">        val settings = adapterHttpClient.settings</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (settings.useCookies)</span>
<span class="fc" id="L147">            adapterHttpClient.cookies = adapterJettyClient.cookieStore.cookies.map {</span>
<span class="fc" id="L148">                Cookie(it.name, it.value, it.maxAge, it.secure)</span>
            }

<span class="fc" id="L151">        return HttpClientResponse(</span>
<span class="fc" id="L152">            body = bodyString,</span>
<span class="fc" id="L153">            headers = convertHeaders(response.headers),</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">            contentType = response.headers[&quot;content-type&quot;]?.let { parseContentType(it) },</span>
<span class="fc" id="L155">            cookies = adapterHttpClient.cookies,</span>
<span class="fc" id="L156">            status = HttpStatus(response.status),</span>
<span class="fc" id="L157">            contentLength = bodyString.length.toLong(),</span>
        )
    }

    private fun convertHeaders(headers: HttpFields): Headers =
<span class="fc" id="L162">        Headers(</span>
<span class="fc" id="L163">            headers</span>
<span class="fc" id="L164">                .fieldNamesCollection</span>
<span class="fc" id="L165">                .map { it.lowercase() }</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">                .filter { it !in checkedHeaders }</span>
<span class="fc" id="L167">                .map { Header(it, headers.getValuesList(it)) }</span>
<span class="fc" id="L168">        )</span>

    private fun createJettyRequest(
        adapterHttpClient: HttpClient,
        adapterJettyClient: JettyHttpClient,
        request: HttpClientRequest
    ): Request {

<span class="fc" id="L176">        val settings = adapterHttpClient.settings</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">        val contentType = request.contentType ?: settings.contentType</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        val authorization = request.authorization ?: settings.authorization</span>

<span class="fc bfc" id="L180" title="All 2 branches covered.">        if (settings.useCookies)</span>
<span class="fc" id="L181">            addCookies(adapterHttpClient, adapterJettyClient.cookieStore, request.cookies)</span>

<span class="fc" id="L183">        val jettyRequest = adapterJettyClient</span>
<span class="fc" id="L184">            .newRequest(URI(settings.baseUrl.toString() + request.path))</span>
<span class="fc" id="L185">            .method(HttpMethod.valueOf(request.method.toString()))</span>
<span class="fc" id="L186">            .headers {</span>
<span class="fc" id="L187">                it.remove(&quot;accept-encoding&quot;) // Don't send encoding by default</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">                if (contentType != null)</span>
<span class="fc" id="L189">                    it.put(&quot;content-type&quot;, contentType.text)</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">                if (authorization != null)</span>
<span class="fc" id="L191">                    it.put(&quot;authorization&quot;, authorization.text)</span>
<span class="fc" id="L192">                (settings.headers + request.headers).values.forEach { (k, v) -&gt; it.put(k, v) }</span>
<span class="fc" id="L193">            }</span>
<span class="fc" id="L194">            .body(createBody(request))</span>
<span class="pc" id="L195">            .accept(*request.accept.map { it.text }.toTypedArray())</span>

<span class="fc" id="L197">        request.queryParameters</span>
<span class="fc" id="L198">            .forEach { (k, v) -&gt;</span>
<span class="fc" id="L199">                v.values.forEach { jettyRequest.param(k, it) }</span>
<span class="fc" id="L200">            }</span>

<span class="fc" id="L202">        return jettyRequest</span>
    }

    private fun createBody(request: HttpClientRequest): Request.Content {

<span class="fc bfc" id="L207" title="All 4 branches covered.">        if (request.parts.isEmpty() &amp;&amp; request.formParameters.isEmpty())</span>
<span class="fc" id="L208">            return BytesRequestContent(bodyToBytes(request.body))</span>

<span class="fc" id="L210">        val multiPart = MultiPartRequestContent()</span>

<span class="fc" id="L212">        request.parts.forEach { p -&gt;</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">            if (p.submittedFileName == null)</span>
                // TODO Add content type if present
<span class="fc" id="L215">                multiPart.addFieldPart(p.name, StringRequestContent(p.bodyString()), EMPTY)</span>
            else
<span class="fc" id="L217">                multiPart.addFilePart(</span>
<span class="fc" id="L218">                    p.name,</span>
<span class="fc" id="L219">                    p.submittedFileName,</span>
<span class="fc" id="L220">                    BytesRequestContent(bodyToBytes(p.body)),</span>
<span class="fc" id="L221">                    EMPTY</span>
                )
<span class="fc" id="L223">        }</span>

<span class="fc" id="L225">        request.formParameters</span>
<span class="fc" id="L226">            .forEach { (k, v) -&gt;</span>
<span class="fc" id="L227">                v.values.forEach { multiPart.addFieldPart(k, StringRequestContent(it), EMPTY) }</span>
<span class="fc" id="L228">            }</span>

<span class="fc" id="L230">        multiPart.close()</span>

<span class="fc" id="L232">        return multiPart</span>
    }

    private fun addCookies(client: HttpClient, store: CookieStore, cookies: List&lt;Cookie&gt;) {
<span class="fc" id="L236">        val uri = client.settings.baseUrl.toURI()</span>

<span class="fc" id="L238">        cookies.forEach {</span>
<span class="fc" id="L239">            val httpCookie = java.net.HttpCookie(it.name, it.value)</span>
<span class="fc" id="L240">            httpCookie.secure = it.secure</span>
<span class="fc" id="L241">            httpCookie.maxAge = it.maxAge</span>
<span class="fc" id="L242">            store.add(uri, httpCookie)</span>
<span class="fc" id="L243">        }</span>
<span class="fc" id="L244">    }</span>

    private fun sslContext(settings: HttpClientSettings): ClientSslContextFactory =
<span class="fc" id="L247">        when {</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">            settings.insecure -&gt;</span>
<span class="fc" id="L249">                ClientSslContextFactory().apply { isTrustAll = true }</span>

<span class="fc bfc" id="L251" title="All 2 branches covered.">            settings.sslSettings != null -&gt; {</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">                val sslSettings = settings.sslSettings ?: fail</span>
<span class="fc" id="L253">                val keyStore = sslSettings.keyStore</span>
<span class="fc" id="L254">                val trustStore = sslSettings.trustStore</span>
<span class="fc" id="L255">                val sslContextBuilder = ClientSslContextFactory()</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">                if (keyStore != null) {</span>
<span class="fc" id="L258">                    val store = loadKeyStore(keyStore, sslSettings.keyStorePassword)</span>
<span class="fc" id="L259">                    sslContextBuilder.keyStore = store</span>
<span class="fc" id="L260">                    sslContextBuilder.keyStorePassword = sslSettings.keyStorePassword</span>
                }

<span class="fc bfc" id="L263" title="All 2 branches covered.">                if (trustStore != null) {</span>
<span class="fc" id="L264">                    val store = loadKeyStore(trustStore, sslSettings.trustStorePassword)</span>
<span class="fc" id="L265">                    sslContextBuilder.trustStore = store</span>
<span class="fc" id="L266">                    sslContextBuilder.setTrustStorePassword(sslSettings.trustStorePassword)</span>
                }

<span class="fc" id="L269">                sslContextBuilder</span>
            }

            else -&gt;
<span class="fc" id="L273">                ClientSslContextFactory()</span>
<span class="fc" id="L274">        }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>